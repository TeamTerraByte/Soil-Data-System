<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ThingSpeak Soil Graphs (Zipper + Theme Toggle + Timestamps)</title>

 <style>
  html[data-theme="dark"] { color-scheme: dark; }
  html[data-theme="light"] { color-scheme: light; }

  :root{
    --ctrl-h: 40px;   /* tweak to 38px or 39px if you want tighter */
    --ctrl-py: 8px;   /* vertical padding baseline */
  }

  body{
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    margin:0;
    padding:16px;
    max-width: 1250px;
    margin-inline:auto;
    background: var(--bg);
    color: var(--fg);
  }

  html[data-theme="light"]{
    --bg:#ffffff; --fg:#111111; --card:#f6f7f9; --border:#c8ccd3;
    --input-bg:#ffffff; --input-fg:#111111; --muted:rgba(0,0,0,0.75);
    --btn-bg:#111111; --btn-fg:#ffffff; --btn-border:#111111;
    --error:#b00020;
  }

  html[data-theme="dark"]{
    --bg:#0b0d10; --fg:#ffffff; --card:#121620; --border:rgba(255,255,255,0.20);
    --input-bg:#0f131b; --input-fg:#ffffff; --muted:rgba(255,255,255,0.80);
    --btn-bg:#ffffff; --btn-fg:#111111; --btn-border:#ffffff;
    --error:#ff6b6b;
  }

  h1{ font-size:1.2rem; margin:0; }
  h2{ font-size:1.05rem; margin:0 0 10px; }
  h3{ font-size:1rem; margin:0 0 8px; }

  .topbar{
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap:12px;
    margin-bottom: 12px;
  }
  .themeBtn{
    width:auto;
    padding:10px 12px;
    border-radius: 10px;
    border: 1px solid var(--btn-border);
    background: var(--btn-bg);
    color: var(--btn-fg);
    font-weight: 700;
    cursor: pointer;
    white-space: nowrap;
  }

  .card{
    border:1px solid var(--border);
    border-radius:14px;
    padding:14px;
    margin:12px 0;
    background: var(--card);
  }

  label{ display:block; font-size:.9rem; margin-bottom:6px; color: var(--fg); }
  input, select, button{
    width:100%;
    height: var(--ctrl-h);
    padding: var(--ctrl-py) 10px;
    border-radius:10px;
    border:1px solid var(--border);
    background: var(--input-bg);
    color: var(--input-fg);
    box-sizing:border-box;
    line-height: 1;          /* key: prevents tall inline box */
  }

  button{
    cursor:pointer;
    font-weight:700;
    display:flex;            /* key: centers text nicely */
    align-items:center;
    justify-content:center;
    white-space:nowrap;
  }

  .muted{ color: var(--muted); font-size:.92rem; }
  .help{ margin-top:6px; }
  .errorText{
    color: var(--error);
    font-weight: 650;
    margin-top: 10px;
    white-space: pre-wrap;
    font-size: .95rem;
  }

  /* ----------------------------
     NEW CONTROL PANEL LAYOUT
     ---------------------------- */
  .controls{
    display:grid;
    gap:14px;
  }

  .rowTop{
    display:grid;
    grid-template-columns: 1fr 1.3fr 0.55fr 0.6fr;
    gap:12px;
    align-items:start; /* was end */
  }

  .rowTop > div { display:flex; flex-direction:column; }
  .rowTop .help { margin-top:6px; min-height: 18px; }  /* keeps row consistent */

  .rowSensor{
    display:grid;
    grid-template-columns: 1fr;
    gap:6px;
  }

  .filters{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
    align-items:start;
  }

  .subcard{
    border:1px solid var(--border);
    border-radius:12px;
    padding:12px;
    background: rgba(0,0,0,0.02);
  }
  html[data-theme="dark"] .subcard{
    background: rgba(255,255,255,0.03);
  }

  .subhead{
    font-size:.95rem;
    font-weight:800;
    margin:0 0 10px;
    opacity:.95;
  }

  .row2col{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
    align-items:end;
  }

  .rowApply{
    display:grid;
    grid-template-columns: 0.55fr 1fr;
    gap:12px;
    align-items:end;
    margin-top:10px;
  }
  .validInline{
    text-align:left;
    font-size:.9rem;
    color: var(--muted);
    padding:10px 10px;
    border-radius:10px;
    border:1px dashed var(--border);
    background: rgba(0,0,0,0.02);
  }
  html[data-theme="dark"] .validInline{
    background: rgba(255,255,255,0.03);
  }

  .btnPrimary{
    background: var(--btn-bg);
    color: var(--btn-fg);
    border: 1px solid var(--btn-border);
  }

  details.statusWrap{
    margin-top:10px;
    border-top: 1px solid var(--border);
    padding-top: 10px;
  }
  details.statusWrap > summary{
    cursor:pointer;
    user-select:none;
    font-weight:800;
    color: var(--fg);
    margin-bottom: 8px;
  }
  .status{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    white-space: pre-wrap;
    font-size: .9rem;
    color: var(--muted);
    margin:0;
  }

  @media (max-width: 900px){
    .topbar{ flex-direction: column; align-items: stretch; }
    .themeBtn{ width: 100%; }

    .rowTop{
      grid-template-columns: 1fr;
    }

    .filters{
      grid-template-columns: 1fr;
    }

    .row2col{
      grid-template-columns: 1fr;
    }

    .rowApply{
      grid-template-columns: 1fr;
    }

    .validInline{
      text-align:left;
    }
  }

  /* Existing chart layout kept */
  .twoCol{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:14px;
    align-items:start;
  }
  .col{
    display:grid;
    grid-template-columns: 1fr;
    gap:14px;
  }
  .zipper{
    display:none;
    grid-template-columns: 1fr;
    gap:14px;
  }
  @media (max-width: 900px){
    .twoCol{ display:none; }
    .zipper{ display:grid; }
  }
  .chartCard canvas{ width:100% !important; height:260px !important; }
</style>

</head>

<body>
  <div class="topbar">
    <h1>ThingSpeak Soil Sensor Visualization</h1>
    <button class="themeBtn" id="themeToggleBtn" type="button">Toggle Dark/Light</button>
  </div>

<div class="card">
  <div class="controls">

    <!-- Top row: connection + load -->
    <div class="rowTop">
      <div>
        <label for="channelId">Channel ID</label>
        <input id="channelId" value="3002040" inputmode="numeric" />
      </div>

      <div>
        <label for="readKey">Read API Key</label>
        <input id="readKey" placeholder="XXXXXXXXXXXXXXXX" />
        <div class="muted help">Optional for public channels.</div>
      </div>

      <div>
        <label for="results"># Results</label>
        <input id="results" value="200" inputmode="numeric" />
      </div>

      <div>
        <label>&nbsp;</label>
        <button id="loadBtn" class="btnPrimary" type="button">Load / Refresh</button>
      </div>
    </div>

    <!-- Sensor row -->
    <div class="rowSensor">
      <div>
        <label for="sensorSelect">Sensor (field1 = Device)</label>
        <select id="sensorSelect" disabled>
          <option>Load data first…</option>
        </select>
        <div class="muted help">Hover a point to see its timestamp (created_at).</div>
      </div>
    </div>

    <!-- Filters -->
    <div class="filters">

      <!-- Text date+time -->
      <div class="subcard">
        <div class="subhead">Text filter (date + time)</div>
        <div class="row2col">
          <div>
            <label for="startText">Start</label>
            <input id="startText" placeholder="YYYY-MM-DD HH:MM[:SS]" />
          </div>
          <div>
            <label for="endText">End</label>
            <input id="endText" placeholder="YYYY-MM-DD HH:MM[:SS]" />
          </div>
        </div>
        <div class="muted help">Example: <b>2026-01-07 10:43:12</b></div>
      </div>

      <!-- GUI day range -->
      <div class="subcard">
        <div class="subhead">GUI filter (day range)</div>
        <div class="row2col">
          <div>
            <label for="startDay">Start day</label>
            <input id="startDay" type="date" />
          </div>
          <div>
            <label for="endDay">End day</label>
            <input id="endDay" type="date" />
          </div>
        </div>

        <div class="rowApply">
          <div>
            <button id="applyDateBtn" type="button">Apply</button>
          </div>
          <div class="validInline" id="validRangeText">Valid: (load data)</div>
        </div>

        <div class="muted help">
          Includes <b>all timestamps</b> from start day 00:00:00 through end day 23:59:59 (local time).
          If GUI days are blank, the text filter is used.
        </div>
      </div>

    </div>

    <div class="errorText" id="dateError"></div>

    <!-- Status -->
    <details class="statusWrap" open>
      <summary>Details</summary>
      <pre class="status" id="status"></pre>
    </details>

    <!-- Unusable rows -->
    <details class="statusWrap">
      <summary>Unusable Rows (debug)</summary>
      <div class="muted" id="badSummary" style="margin:6px 0 10px;"></div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
        <button id="downloadBadCsvBtn" type="button" style="width:auto; padding:10px 12px;">Download Unusable CSV</button>
        <button id="clearBadBtn" type="button" style="width:auto; padding:10px 12px;">Clear Log</button>
      </div>

      <div style="overflow:auto; max-height:320px; border:1px solid var(--border); border-radius:10px;">
        <table id="badTable" style="width:100%; border-collapse:collapse; font-size:.9rem;">
          <thead>
            <tr>
              <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border);">Reason</th>
              <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border);">created_at</th>
              <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border);">Device (field1)</th>
              <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border);">Soil Moist (field2)</th>
              <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border);">Soil Temp (field3)</th>
              <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border);">Battery (field4)</th>
              <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border);">entry_id</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="muted" style="margin-top:8px;">
        Showing first <span id="badShownCount">0</span> of <span id="badTotalCount">0</span> unusable row(s).
      </div>
    </details>

  </div>
</div>

  <!-- Desktop / tablet layout -->
  <div class="card twoCol" id="twoColLayout">
    <div class="col">
      <h2>Moisture</h2>
      <div id="moistCol"></div>
    </div>
    <div class="col">
      <h2>Temperature (°C)</h2>
      <div id="tempCol"></div>
    </div>
  </div>

  <!-- Mobile zipper-merged layout -->
  <div class="card zipper" id="zipperLayout">
    <h2>Moisture + Temperature (Zipper)</h2>
    <div id="zipperCol"></div>
  </div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script>
    /*
      UPDATED FIELD MAPPING (per your ThingSpeak screenshot):
        field1 = Device
        field2 = Soil Moist
        field3 = Soil Temp
        field4 = Battery

      Previously, field2 was "Time Since Epoch". You removed it, so we now parse:
        Moisture from field2
        Temperature from field3
        Battery from field4 (logged/parsed, not graphed here)
    */

    const DEPTHS_CM = [-10, -20, -30, -40, -50, -60, -70, -80];
    const depthLabel = (i) => `${DEPTHS_CM[i]} cm`;

    const MOIST_COLOR = "#1f77b4";
    const TEMP_COLOR  = "#d62728";

    // DOM
    const elChannelId = document.getElementById("channelId");
    const elReadKey   = document.getElementById("readKey");
    const elResults   = document.getElementById("results");
    const elLoadBtn   = document.getElementById("loadBtn");
    const elSensorSel = document.getElementById("sensorSelect");
    const elStatus    = document.getElementById("status");
    const elThemeBtn  = document.getElementById("themeToggleBtn");

    const elMoistCol  = document.getElementById("moistCol");
    const elTempCol   = document.getElementById("tempCol");
    const elZipperCol = document.getElementById("zipperCol");

    // Date UI
    const elStartText = document.getElementById("startText");
    const elEndText   = document.getElementById("endText");
    const elStartDay  = document.getElementById("startDay");
    const elEndDay    = document.getElementById("endDay");
    const elApplyDateBtn = document.getElementById("applyDateBtn");
    const elValidRangeText = document.getElementById("validRangeText");
    const elDateError = document.getElementById("dateError");

    // ---- Unusable row logging ----
    const elBadSummary = document.getElementById("badSummary");
    const elBadTable = document.getElementById("badTable");
    const elBadShownCount = document.getElementById("badShownCount");
    const elBadTotalCount = document.getElementById("badTotalCount");
    const elDownloadBadCsvBtn = document.getElementById("downloadBadCsvBtn");
    const elClearBadBtn = document.getElementById("clearBadBtn");

    const BAD_LOG_LIMIT = 250;   // store up to N rows in memory
    const BAD_SHOW_LIMIT = 80;   // show first N rows in table
    let badRowsLog = [];         // { reason, created_at, field1, field2, field3, field4, entry_id }

    let moistCharts = new Array(8).fill(null);
    let tempCharts  = new Array(8).fill(null);
    let moistCards  = new Array(8).fill(null);
    let tempCards   = new Array(8).fill(null);

    // Cached fetch
    let lastFeeds = [];
    let currentSensorName = null;

    // Data min/max from fetched data
    let dataMinMs = null;
    let dataMaxMs = null;

    // Active filter (ms)
    let activeStartMs = null;
    let activeEndMs   = null;

    function setStatus(msg){ elStatus.textContent = msg; }
    function setDateError(msg){ elDateError.textContent = msg || ""; }

    // ---- Theme ----
    function getInitialTheme(){
      const saved = localStorage.getItem("rs_theme");
      if (saved === "dark" || saved === "light") return saved;
      const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
      return prefersDark ? "dark" : "light";
    }
    function currentGraphTextColor(){
      const theme = document.documentElement.getAttribute("data-theme") || "dark";
      return theme === "light" ? "#000000" : "#ffffff";
    }
    function currentGridColor(){
      const theme = document.documentElement.getAttribute("data-theme") || "dark";
      return theme === "light" ? "rgba(0,0,0,0.12)" : "rgba(255,255,255,0.15)";
    }
    function applyChartTheme(){
      const textColor = currentGraphTextColor();
      const gridColor = currentGridColor();
      for (const chart of [...moistCharts, ...tempCharts]){
        if (!chart) continue;
        chart.options.plugins.legend.labels.color = textColor;

        chart.options.scales.x.title.color = textColor;
        chart.options.scales.x.ticks.color = textColor;
        chart.options.scales.x.grid.color  = gridColor;

        chart.options.scales.y.title.color = textColor;
        chart.options.scales.y.ticks.color = textColor;
        chart.options.scales.y.grid.color  = gridColor;

        chart.update();
      }
    }
    function setTheme(theme){
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem("rs_theme", theme);
      applyChartTheme();
      for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
    }
    function toggleTheme(){
      const cur = document.documentElement.getAttribute("data-theme") || "dark";
      setTheme(cur === "dark" ? "light" : "dark");
    }

    // ---- ThingSpeak helpers ----
    function buildThingSpeakUrl(channelId, readKey, results){
      const base = `https://api.thingspeak.com/channels/${encodeURIComponent(channelId)}/feeds.json`;
      const params = new URLSearchParams();
      params.set("results", String(results || 200));
      if (readKey && readKey.trim().length > 0) params.set("api_key", readKey.trim());
      return `${base}?${params.toString()}`;
    }
    function parseSignedFloat(s){
      const v = Number.parseFloat(String(s).trim());
      return Number.isFinite(v) ? v : null;
    }

    // Parses strings like: "Moist,+001.91,+006.26,...(8 vals)" or "Temp,+023.13,...(8 vals)"
    function parseFieldSeries(fieldStr){
      if (!fieldStr || typeof fieldStr !== "string") return null;
      const parts = fieldStr.split(",").map(x => x.trim()).filter(Boolean);
      if (parts.length < 2) return null;
      const nums = parts.slice(1).map(parseSignedFloat);
      if (nums.some(v => v === null)) return null;
      if (nums.length !== 8) return null;
      return nums;
    }

    // Parses Battery field (common formats: "Batt,4.04" OR "4.04")
    function parseBattery(fieldStr){
      if (fieldStr == null) return null;
      const s = String(fieldStr).trim();
      if (!s) return null;
      const parts = s.split(",").map(x => x.trim()).filter(Boolean);
      const candidate = parts.length >= 2 ? parts[parts.length - 1] : parts[0];
      return parseSignedFloat(candidate);
    }

    function uniqueSensors(feeds){
      const set = new Set();
      for (const f of feeds){
        const s = (f?.field1 || "").trim();
        if (s) set.add(s);
      }
      return Array.from(set).sort((a,b) => a.localeCompare(b));
    }

    function parseCreatedAtToMs(createdAt){
      const ms = new Date(createdAt).getTime();
      return Number.isFinite(ms) ? ms : null;
    }
    function formatCreatedAt(createdAt){
      const d = new Date(createdAt);
      if (Number.isNaN(d.getTime())) return String(createdAt);
      return d.toLocaleString();
    }
    function formatEpochTick(value){
      const d = new Date(Number(value));
      if (Number.isNaN(d.getTime())) return String(value);
      return d.toLocaleString();
    }

    // local YYYY-MM-DD from ms
    function msToLocalDay(ms){
      const d = new Date(ms);
      const pad = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    }

    // Build ms range from day inputs (inclusive whole days, local time)
    function dayStartMs(dayStr){
      return new Date(`${dayStr}T00:00:00`).getTime();
    }
    function dayEndMs(dayStr){
      return new Date(`${dayStr}T23:59:59.999`).getTime();
    }

    // ---- Text range parsing/validation ----
    function parseTypedDateToMs(s){
      if (!s || typeof s !== "string") return null;
      const t = s.trim();
      if (!t) return null;
      const normalized = t.includes("T") ? t : t.replace(" ", "T");
      const ms = new Date(normalized).getTime();
      return Number.isFinite(ms) ? ms : null;
    }

    function computeGlobalMinMaxMs(feeds){
      let min = Infinity, max = -Infinity;
      for (const f of feeds){
        const ms = parseCreatedAtToMs(f?.created_at);
        if (!Number.isFinite(ms)) continue;
        if (ms < min) min = ms;
        if (ms > max) max = ms;
      }
      if (!Number.isFinite(min) || !Number.isFinite(max) || min === Infinity || max === -Infinity) {
        return { minMs: null, maxMs: null };
      }
      return { minMs: min, maxMs: max };
    }

    function updateValidRangeUI(){
      if (!Number.isFinite(dataMinMs) || !Number.isFinite(dataMaxMs)) {
        elValidRangeText.textContent = "";
        elStartDay.min = ""; elStartDay.max = "";
        elEndDay.min = "";   elEndDay.max = "";
        return;
      }
      const minStr = new Date(dataMinMs).toLocaleString();
      const maxStr = new Date(dataMaxMs).toLocaleString();
      elValidRangeText.textContent = `Valid: ${minStr} → ${maxStr}`;

      const minDay = msToLocalDay(dataMinMs);
      const maxDay = msToLocalDay(dataMaxMs);
      elStartDay.min = minDay;
      elStartDay.max = maxDay;
      elEndDay.min = minDay;
      elEndDay.max = maxDay;
    }

    function setDefaultRangesFromData(){
      if (!Number.isFinite(dataMinMs) || !Number.isFinite(dataMaxMs)) return;

      activeStartMs = dataMinMs;
      activeEndMs   = dataMaxMs;

      elStartDay.value = msToLocalDay(dataMinMs);
      elEndDay.value   = msToLocalDay(dataMaxMs);

      elStartText.value = new Date(activeStartMs).toLocaleString();
      elEndText.value   = new Date(activeEndMs).toLocaleString();
    }

    function validateAndApplyFilter(){
      setDateError("");

      if (!Number.isFinite(dataMinMs) || !Number.isFinite(dataMaxMs)) {
        setDateError("Load data first so the valid date range can be determined.");
        return false;
      }

      const guiStartDay = elStartDay.value.trim();
      const guiEndDay   = elEndDay.value.trim();
      const guiHasBoth = guiStartDay && guiEndDay;

      if (guiHasBoth){
        if (guiEndDay < guiStartDay){
          setDateError("End day must be the same day as or after the start day.");
          return false;
        }

        const minDay = msToLocalDay(dataMinMs);
        const maxDay = msToLocalDay(dataMaxMs);

        if (guiStartDay < minDay || guiEndDay > maxDay){
          setDateError(`GUI day range out of bounds. Choose between ${minDay} and ${maxDay}.`);
          return false;
        }

        activeStartMs = dayStartMs(guiStartDay);
        activeEndMs   = dayEndMs(guiEndDay);

        elStartText.value = new Date(activeStartMs).toLocaleString();
        elEndText.value   = new Date(activeEndMs).toLocaleString();

        rerenderAll();
        return true;
      }

      const startMs = parseTypedDateToMs(elStartText.value);
      const endMs   = parseTypedDateToMs(elEndText.value);

      if (!Number.isFinite(startMs) || !Number.isFinite(endMs)) {
        setDateError("Invalid start/end. Use: 2026-01-07 10:43:12 (or set the GUI day range).");
        return false;
      }
      if (startMs > endMs) {
        setDateError("Start must be earlier than (or equal to) End.");
        return false;
      }
      if (startMs < dataMinMs || endMs > dataMaxMs) {
        setDateError(
          `Out of range. Choose between:\n${new Date(dataMinMs).toLocaleString()}\n${new Date(dataMaxMs).toLocaleString()}`
        );
        return false;
      }

      activeStartMs = startMs;
      activeEndMs   = endMs;

      elStartDay.value = "";
      elEndDay.value = "";

      rerenderAll();
      return true;
    }

    function passesFilter(ms){
      if (Number.isFinite(activeStartMs) && ms < activeStartMs) return false;
      if (Number.isFinite(activeEndMs) && ms > activeEndMs) return false;
      return true;
    }

    // ---- Layout ----
    function isMobile(){ return window.matchMedia("(max-width: 900px)").matches; }
    function clearContainers(){
      elMoistCol.innerHTML  = "";
      elTempCol.innerHTML   = "";
      elZipperCol.innerHTML = "";
    }
    function placeCardsForViewport(){
      clearContainers();
      if (isMobile()){
        for (let i = 0; i < 8; i++){
          elZipperCol.appendChild(moistCards[i]);
          elZipperCol.appendChild(tempCards[i]);
        }
      } else {
        for (let i = 0; i < 8; i++){
          elMoistCol.appendChild(moistCards[i]);
          elTempCol.appendChild(tempCards[i]);
        }
      }
    }
    function debounce(fn, wait){
      let t = null;
      return (...args) => {
        if (t) clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    // ---- Charts ----
    function makeDepthChart(canvas, yLabel){
      const textColor = currentGraphTextColor();
      const gridColor = currentGridColor();

      return new Chart(canvas.getContext("2d"), {
        type: "scatter",
        data: { datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          plugins: {
            legend: {
              display: true,
              position: "top",
              labels: { color: textColor }
            },
            tooltip: {
              enabled: true,
              mode: "nearest",
              intersect: true,
              callbacks: {
                title: (items) => {
                  const p = items?.[0]?.raw;
                  return p?.created_at_label ? p.created_at_label : "";
                },
                label: (item) => {
                  const y = item?.raw?.y;
                  return Number.isFinite(y) ? `Value: ${y}` : `Value: ${y}`;
                }
              }
            }
          },
          interaction: {
            mode: "nearest",
            intersect: true,
            axis: "xy"
          },
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Time", color: textColor },
              ticks: { color: textColor, callback: (val) => formatEpochTick(val) },
              grid: { color: gridColor }
            },
            y: {
              title: { display: true, text: yLabel, color: textColor },
              ticks: { color: textColor },
              grid: { color: gridColor }
            }
          },
          elements: {
            line: { tension: 0.15 },
            point: { radius: 2.2, hoverRadius: 5, hitRadius: 10 }
          }
        }
      });
    }

    function makeChartCard(titleText){
      const card = document.createElement("div");
      card.className = "card chartCard";
      const h = document.createElement("h3");
      h.textContent = titleText;
      const canvas = document.createElement("canvas");
      card.appendChild(h);
      card.appendChild(canvas);
      return { card, canvas };
    }

    function destroyAllCharts(){
      for (const c of moistCharts) c?.destroy?.();
      for (const c of tempCharts)  c?.destroy?.();
      moistCharts = new Array(8).fill(null);
      tempCharts  = new Array(8).fill(null);
      moistCards  = new Array(8).fill(null);
      tempCards   = new Array(8).fill(null);
      clearContainers();
    }

    function buildCardsAndChartsOnce(){
      for (let i = 0; i < 8; i++){
        const m = makeChartCard(`Moisture ${depthLabel(i)}`);
        moistCards[i]  = m.card;
        moistCharts[i] = makeDepthChart(m.canvas, "Moisture (percent)");

        const t = makeChartCard(`Temperature ${depthLabel(i)}`);
        tempCards[i]  = t.card;
        tempCharts[i] = makeDepthChart(t.canvas, "Temperature (°C)");
      }
      placeCardsForViewport();

      window.addEventListener("resize", debounce(() => {
        placeCardsForViewport();
        for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
      }, 150));
    }

    // ---- Unusable row logging helpers ----
    function logBadRow(reason, feed){
      if (badRowsLog.length >= BAD_LOG_LIMIT) return;

      badRowsLog.push({
        reason,
        created_at: String(feed?.created_at ?? ""),
        field1: String(feed?.field1 ?? ""),
        field2: String(feed?.field2 ?? ""),
        field3: String(feed?.field3 ?? ""),
        field4: String(feed?.field4 ?? ""),
        entry_id: String(feed?.entry_id ?? "")
      });
    }

    function summarizeBadRows(){
      const counts = new Map();
      for (const r of badRowsLog){
        counts.set(r.reason, (counts.get(r.reason) || 0) + 1);
      }
      return Array.from(counts.entries()).sort((a,b) => b[1]-a[1]);
    }

    function renderBadRowsUI(){
      if (!elBadTable) return;

      const summary = summarizeBadRows();
      const total = badRowsLog.length;

      elBadTotalCount.textContent = String(total);

      if (total === 0){
        if (elBadSummary) elBadSummary.textContent = "No unusable rows logged.";
        if (elBadShownCount) elBadShownCount.textContent = "0";
        elBadTable.querySelector("tbody").innerHTML = "";
        return;
      }

      if (elBadSummary){
        elBadSummary.innerHTML =
          summary.map(([reason, n]) => `${escapeHtml(reason)}: <b>${n}</b>`).join(" &nbsp;•&nbsp; ");
      }

      const tbody = elBadTable.querySelector("tbody");
      const show = badRowsLog.slice(0, BAD_SHOW_LIMIT);
      if (elBadShownCount) elBadShownCount.textContent = String(show.length);

      tbody.innerHTML = show.map(r => `
        <tr>
          <td style="padding:8px; border-bottom:1px solid var(--border);">${escapeHtml(r.reason)}</td>
          <td style="padding:8px; border-bottom:1px solid var(--border);">${escapeHtml(r.created_at)}</td>
          <td style="padding:8px; border-bottom:1px solid var(--border);">${escapeHtml(r.field1)}</td>
          <td style="padding:8px; border-bottom:1px solid var(--border); max-width:240px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(r.field2)}</td>
          <td style="padding:8px; border-bottom:1px solid var(--border); max-width:240px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(r.field3)}</td>
          <td style="padding:8px; border-bottom:1px solid var(--border); max-width:140px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(r.field4)}</td>
          <td style="padding:8px; border-bottom:1px solid var(--border);">${escapeHtml(r.entry_id)}</td>
        </tr>
      `).join("");
    }

    function badRowsToCsv(){
      const header = ["reason","created_at","field1","field2","field3","field4","entry_id"];
      const lines = [header.join(",")];
      for (const r of badRowsLog){
        const row = [
          r.reason, r.created_at, r.field1, r.field2, r.field3, r.field4, r.entry_id
        ].map(v => `"${String(v).replace(/"/g,'""')}"`);
        lines.push(row.join(","));
      }
      return lines.join("\n");
    }

    function downloadTextFile(filename, text){
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function clearBadLog(){
      badRowsLog = [];
      renderBadRowsUI();
    }

    // ---- Data parse / render ----
    function buildRowsForSensor(feeds, sensorName){
      const rows = [];

      for (const f of feeds){
        const fSensor = (f?.field1 || "").trim();

        // Not the selected sensor -> ignore (not "unusable")
        if (fSensor !== sensorName) continue;

        const createdAt = String(f?.created_at || "").trim();
        const ms = parseCreatedAtToMs(createdAt);
        if (!Number.isFinite(ms)){
          logBadRow("BAD_CREATED_AT", f);
          continue;
        }

        if (!passesFilter(ms)){
          logBadRow("OUTSIDE_ACTIVE_WINDOW", f);
          continue;
        }

        // UPDATED: Moisture is now field2, Temp is field3
        const moist = parseFieldSeries(f?.field2);
        if (!moist){
          logBadRow("BAD_FIELD2_MOIST_PARSE", f);
          continue;
        }

        const temp = parseFieldSeries(f?.field3);
        if (!temp){
          logBadRow("BAD_FIELD3_TEMP_PARSE", f);
          continue;
        }

        // Battery is field4 (optional for plotting, but we parse it for debugging/visibility)
        const battery = parseBattery(f?.field4);
        // If you want battery REQUIRED, uncomment below:
        // if (battery === null){ logBadRow("BAD_FIELD4_BATT_PARSE", f); continue; }

        rows.push({
          ms,
          created_at: createdAt,
          created_at_label: formatCreatedAt(createdAt),
          moist,
          temp,
          battery
        });
      }

      rows.sort((a,b) => a.ms - b.ms);
      return rows;
    }

    function renderSensor(rows, sensorName){
      currentSensorName = sensorName;

      for (let i = 0; i < 8; i++){
        const moistData = rows.map(r => ({
          x: r.ms,
          y: r.moist[i],
          created_at_label: r.created_at_label
        }));
        const tempData  = rows.map(r => ({
          x: r.ms,
          y: r.temp[i],
          created_at_label: r.created_at_label
        }));

        moistCharts[i].data.datasets = [{
          label: `Moisture ${DEPTHS_CM[i]} cm`,
          showLine: true,
          data: moistData,
          borderColor: MOIST_COLOR,
          backgroundColor: MOIST_COLOR
        }];

        tempCharts[i].data.datasets = [{
          label: `Temperature ${DEPTHS_CM[i]} cm`,
          showLine: true,
          data: tempData,
          borderColor: TEMP_COLOR,
          backgroundColor: TEMP_COLOR
        }];

        moistCharts[i].update();
        tempCharts[i].update();
      }

      applyChartTheme();

      const earliest = rows.length ? rows[0].created_at_label : "n/a";
      const latest = rows.length ? rows[rows.length - 1].created_at_label : "n/a";

      setStatus((prev => {
        const header = (prev || "").split("\n")[0] || "";
        const headerLine = header.startsWith("Loaded") ? header + "\n" : "";
        return headerLine +
          `Showing sensor: ${sensorName}\n` +
          `Usable rows (in view): ${rows.length}\n` +
          `Earliest in view: ${earliest}\n` +
          `Latest in view: ${latest}\n` +
          `Active window: ${new Date(activeStartMs).toLocaleString()} → ${new Date(activeEndMs).toLocaleString()}`;
      })(elStatus.textContent));
    }

    function rerenderAll(){
      if (!currentSensorName || !Array.isArray(lastFeeds) || lastFeeds.length === 0) return;
      clearBadLog();
      const rows = buildRowsForSensor(lastFeeds, currentSensorName);
      renderSensor(rows, currentSensorName);
      renderBadRowsUI();
    }

    async function loadAndRender(){
      saveReadKey(elReadKey.value);
      setDateError("");

      clearBadLog();

      elSensorSel.disabled = true;
      elSensorSel.innerHTML = `<option>Loading…</option>`;
      setStatus("Loading ThingSpeak data…");

      const channelId = elChannelId.value.trim();
      const readKey   = elReadKey.value.trim();
      const results   = Number.parseInt(elResults.value.trim(), 10) || 200;
      const url = buildThingSpeakUrl(channelId, readKey, results);

      let json;
      try{
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
        json = await res.json();
      } catch(e){
        setStatus(`Failed to fetch.\nURL: ${url}\nError: ${e?.message || e}`);
        elSensorSel.innerHTML = `<option>Load failed</option>`;
        return;
      }

      const feeds = Array.isArray(json?.feeds) ? json.feeds : [];
      if (feeds.length === 0){
        setStatus(`No feeds returned.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No data</option>`;
        return;
      }

      lastFeeds = feeds;

      const mm = computeGlobalMinMaxMs(feeds);
      dataMinMs = mm.minMs;
      dataMaxMs = mm.maxMs;
      updateValidRangeUI();

      if (!Number.isFinite(activeStartMs) || !Number.isFinite(activeEndMs) ||
          activeStartMs < dataMinMs || activeEndMs > dataMaxMs) {
        setDefaultRangesFromData();
      }

      const sensors = uniqueSensors(feeds);
      if (sensors.length === 0){
        setStatus(`No sensors found in field1.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No sensors found</option>`;
        return;
      }

      if (!moistCharts[0] || !tempCharts[0]){
        destroyAllCharts();
        buildCardsAndChartsOnce();
      } else {
        placeCardsForViewport();
        for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
      }

      elSensorSel.disabled = false;
      elSensorSel.innerHTML = sensors.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");

      const defaultSensor = sensors[0];
      const rows = buildRowsForSensor(feeds, defaultSensor);
      renderSensor(rows, defaultSensor);
      renderBadRowsUI();

      elSensorSel.onchange = () => {
        const sensorName = elSensorSel.value;
        clearBadLog();
        const rows2 = buildRowsForSensor(lastFeeds, sensorName);
        renderSensor(rows2, sensorName);
        renderBadRowsUI();
      };

      const chName = json?.channel?.name ? ` (${json.channel.name})` : "";
      setStatus(
        `Loaded ${feeds.length} rows from channel ${channelId}${chName}.\n` +
        `Discovered ${sensors.length} sensor(s). Showing: ${defaultSensor}\n` +
        `Usable rows (in view): ${rows.length}`
      );
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    // ---- Persist Read API Key (localStorage) ----
    const READKEY_STORAGE_KEY = "rs_thingspeak_read_api_key_v1";

    function loadSavedReadKey() {
      const saved = localStorage.getItem(READKEY_STORAGE_KEY);
      if (saved && typeof saved === "string") {
        elReadKey.value = saved;
      }
    }

    function saveReadKey(value) {
      const v = String(value || "").trim();
      if (v.length === 0) {
        localStorage.removeItem(READKEY_STORAGE_KEY);
      } else {
        localStorage.setItem(READKEY_STORAGE_KEY, v);
      }
    }

    elReadKey.addEventListener("input", () => saveReadKey(elReadKey.value));
    elReadKey.addEventListener("change", () => saveReadKey(elReadKey.value));
    elReadKey.addEventListener("blur", () => saveReadKey(elReadKey.value));

    // ---- Date UI events ----
    elApplyDateBtn.addEventListener("click", () => validateAndApplyFilter());

    elStartDay.addEventListener("change", () => {
      if (elStartDay.value) elEndDay.min = elStartDay.value;
      validateAndApplyFilter();
    });
    elEndDay.addEventListener("change", () => validateAndApplyFilter());

    elStartText.addEventListener("keydown", (e) => { if (e.key === "Enter") validateAndApplyFilter(); });
    elEndText.addEventListener("keydown", (e) => { if (e.key === "Enter") validateAndApplyFilter(); });

    // ---- Download/Clear bad log buttons ----
    elDownloadBadCsvBtn?.addEventListener("click", () => {
      const csv = badRowsToCsv();
      downloadTextFile("thingspeak_unusable_rows.csv", csv);
    });

    elClearBadBtn?.addEventListener("click", () => clearBadLog());

    // ---- Init ----
    setTheme(getInitialTheme());
    loadSavedReadKey();
    elThemeBtn.addEventListener("click", toggleTheme);
    elLoadBtn.addEventListener("click", loadAndRender);

    // First load
    loadAndRender();
  </script>
</body>
</html>
