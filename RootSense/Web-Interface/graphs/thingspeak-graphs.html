<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ThingSpeak Soil Graphs (Zipper + Theme Toggle + Timestamps)</title>

  <style>
    html[data-theme="dark"] { color-scheme: dark; }
    html[data-theme="light"] { color-scheme: light; }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin:0;
      padding:16px;
      max-width: 1250px;
      margin-inline:auto;
      background: var(--bg);
      color: var(--fg);
    }

    /* Light theme (high contrast) */
    html[data-theme="light"]{
      --bg: #ffffff;
      --fg: #111111;
      --card: #f6f7f9;
      --border: #c8ccd3;
      --input-bg: #ffffff;
      --input-fg: #111111;
      --muted: rgba(0,0,0,0.75);
      --btn-bg: #111111;
      --btn-fg: #ffffff;
      --btn-border: #111111;
    }

    /* Dark theme (high contrast) */
    html[data-theme="dark"]{
      --bg: #0b0d10;
      --fg: #ffffff;
      --card: #121620;
      --border: rgba(255,255,255,0.20);
      --input-bg: #0f131b;
      --input-fg: #ffffff;
      --muted: rgba(255,255,255,0.80);
      --btn-bg: #ffffff;
      --btn-fg: #111111;
      --btn-border: #ffffff;
    }

    h1{ font-size:1.2rem; margin:0; }
    h2{ font-size:1.05rem; margin:0 0 10px; }
    h3{ font-size:1rem; margin:0 0 8px; }

    .topbar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap:12px;
      margin-bottom: 12px;
    }
    .themeBtn{
      width:auto;
      padding:10px 12px;
      border-radius: 10px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-fg);
      font-weight: 700;
      cursor: pointer;
      white-space: nowrap;
    }

    .card{
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      margin:12px 0;
      background: var(--card);
    }

    label{ display:block; font-size:.9rem; margin-bottom:6px; color: var(--fg); }
    input, select, button{
      width:100%;
      padding:10px;
      border-radius:10px;
      border:1px solid var(--border);
      background: var(--input-bg);
      color: var(--input-fg);
      box-sizing:border-box;
    }
    button{ cursor:pointer; font-weight:600; }

    .grid3{
      display:grid;
      grid-template-columns: 1.2fr 1.2fr 0.6fr;
      gap:12px;
      align-items:end;
    }
    .row2{
      display:grid;
      grid-template-columns: 1fr 0.35fr;
      gap:12px;
      align-items:end;
      margin-top:12px;
    }
    @media (max-width: 900px){
      .grid3{ grid-template-columns:1fr; }
      .row2{ grid-template-columns:1fr; }
      .topbar{ flex-direction: column; align-items: stretch; }
      .themeBtn{ width: 100%; }
    }

    .muted{ opacity:1; color: var(--muted); font-size:.95rem; margin-top:6px; }
    .status{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      white-space: pre-wrap;
      font-size: .9rem;
      color: var(--muted);
      margin-top: 12px;
    }

    /* Desktop: two columns (moist left, temp right) */
    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:start;
    }
    .col{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }

    /* Mobile: zipper merge */
    .zipper{
      display:none;
      grid-template-columns: 1fr;
      gap:14px;
    }
    @media (max-width: 900px){
      .twoCol{ display:none; }
      .zipper{ display:grid; }
    }

    .chartCard canvas{ width:100% !important; height:260px !important; }
  </style>
</head>

<body>
  <div class="topbar">
    <h1>ThingSpeak Soil Sensor Visualization</h1>
    <button class="themeBtn" id="themeToggleBtn" type="button">Toggle Dark/Light</button>
  </div>

  <div class="card">
    <div class="grid3">
      <div>
        <label for="channelId">Channel ID</label>
        <input id="channelId" value="3002040" inputmode="numeric" />
      </div>
      <div>
        <label for="readKey">Read API Key (optional for public channels)</label>
        <input id="readKey" placeholder="XXXXXXXXXXXXXXXX" />
      </div>
      <div>
        <label for="results"># Results</label>
        <input id="results" value="800" inputmode="numeric" />
      </div>
    </div>

    <div class="row2">
      <div>
        <label for="sensorSelect">Select sensor (field1)</label>
        <select id="sensorSelect" disabled>
          <option>Load data first…</option>
        </select>
        <div class="muted">Hover a point to see its <b>created_at</b> timestamp.</div>
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="loadBtn" type="button">Load / Refresh</button>
      </div>
    </div>

    <div class="status" id="status"></div>
  </div>

  <!-- Desktop / tablet layout -->
  <div class="card twoCol" id="twoColLayout">
    <div class="col">
      <h2>Moisture</h2>
      <div id="moistCol"></div>
    </div>
    <div class="col">
      <h2>Temperature (°C)</h2>
      <div id="tempCol"></div>
    </div>
  </div>

  <!-- Mobile zipper-merged layout -->
  <div class="card zipper" id="zipperLayout">
    <h2>Moisture + Temperature (Zipper)</h2>
    <div id="zipperCol"></div>
  </div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script>
    const DEPTHS_CM = [-10, -20, -30, -40, -50, -60, -70, -80];
    const depthLabel = (i) => `${DEPTHS_CM[i]} cm`;

    const MOIST_COLOR = "#1f77b4";
    const TEMP_COLOR  = "#d62728";

    // DOM
    const elChannelId = document.getElementById("channelId");
    const elReadKey   = document.getElementById("readKey");
    const elResults   = document.getElementById("results");
    const elLoadBtn   = document.getElementById("loadBtn");
    const elSensorSel = document.getElementById("sensorSelect");
    const elStatus    = document.getElementById("status");
    const elThemeBtn  = document.getElementById("themeToggleBtn");

    const elMoistCol  = document.getElementById("moistCol");
    const elTempCol   = document.getElementById("tempCol");
    const elZipperCol = document.getElementById("zipperCol");

    let moistCharts = new Array(8).fill(null);
    let tempCharts  = new Array(8).fill(null);
    let moistCards  = new Array(8).fill(null);
    let tempCards   = new Array(8).fill(null);

    function setStatus(msg){ elStatus.textContent = msg; }

    // ---- Theme ----
    function getInitialTheme(){
      const saved = localStorage.getItem("rs_theme");
      if (saved === "dark" || saved === "light") return saved;
      const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
      return prefersDark ? "dark" : "light";
    }
    function currentGraphTextColor(){
      const theme = document.documentElement.getAttribute("data-theme") || "dark";
      return theme === "light" ? "#000000" : "#ffffff";
    }
    function currentGridColor(){
      const theme = document.documentElement.getAttribute("data-theme") || "dark";
      return theme === "light" ? "rgba(0,0,0,0.12)" : "rgba(255,255,255,0.15)";
    }
    function applyChartTheme(){
      const textColor = currentGraphTextColor();
      const gridColor = currentGridColor();
      for (const chart of [...moistCharts, ...tempCharts]){
        if (!chart) continue;
        chart.options.plugins.legend.labels.color = textColor;

        chart.options.scales.x.title.color = textColor;
        chart.options.scales.x.ticks.color = textColor;
        chart.options.scales.x.grid.color  = gridColor;

        chart.options.scales.y.title.color = textColor;
        chart.options.scales.y.ticks.color = textColor;
        chart.options.scales.y.grid.color  = gridColor;

        chart.update();
      }
    }
    function setTheme(theme){
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem("rs_theme", theme);
      applyChartTheme();
      for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
    }
    function toggleTheme(){
      const cur = document.documentElement.getAttribute("data-theme") || "dark";
      setTheme(cur === "dark" ? "light" : "dark");
    }

    // ---- ThingSpeak helpers ----
    function buildThingSpeakUrl(channelId, readKey, results){
      const base = `https://api.thingspeak.com/channels/${encodeURIComponent(channelId)}/feeds.json`;
      const params = new URLSearchParams();
      params.set("results", String(results || 800));
      if (readKey && readKey.trim().length > 0) params.set("api_key", readKey.trim());
      return `${base}?${params.toString()}`;
    }
    function parseSignedFloat(s){
      const v = Number.parseFloat(String(s).trim());
      return Number.isFinite(v) ? v : null;
    }
    function parseFieldSeries(fieldStr){
      if (!fieldStr || typeof fieldStr !== "string") return null;
      const parts = fieldStr.split(",").map(x => x.trim()).filter(Boolean);
      if (parts.length < 2) return null;
      const nums = parts.slice(1).map(parseSignedFloat);
      if (nums.some(v => v === null)) return null;
      if (nums.length !== 8) return null;
      return nums;
    }
    function uniqueSensors(feeds){
      const set = new Set();
      for (const f of feeds){
        const s = (f?.field1 || "").trim();
        if (s) set.add(s);
      }
      return Array.from(set).sort((a,b) => a.localeCompare(b));
    }

    function parseCreatedAtToMs(createdAt){
      // created_at includes timezone offset, so Date() parses it well.
      const ms = new Date(createdAt).getTime();
      return Number.isFinite(ms) ? ms : null;
    }
    function formatCreatedAt(createdAt){
      const d = new Date(createdAt);
      if (Number.isNaN(d.getTime())) return String(createdAt);
      return d.toLocaleString(); // local display
    }
    function formatEpochTick(value){
      // value is milliseconds (ms) in this version
      const d = new Date(Number(value));
      if (Number.isNaN(d.getTime())) return String(value);
      return d.toLocaleString();
    }

    // ---- Layout ----
    function isMobile(){ return window.matchMedia("(max-width: 900px)").matches; }
    function clearContainers(){
      elMoistCol.innerHTML  = "";
      elTempCol.innerHTML   = "";
      elZipperCol.innerHTML = "";
    }
    function placeCardsForViewport(){
      clearContainers();
      if (isMobile()){
        for (let i = 0; i < 8; i++){
          elZipperCol.appendChild(moistCards[i]);
          elZipperCol.appendChild(tempCards[i]);
        }
      } else {
        for (let i = 0; i < 8; i++){
          elMoistCol.appendChild(moistCards[i]);
          elTempCol.appendChild(tempCards[i]);
        }
      }
    }
    function debounce(fn, wait){
      let t = null;
      return (...args) => {
        if (t) clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    // ---- Charts ----
    function makeDepthChart(canvas, yLabel){
      const textColor = currentGraphTextColor();
      const gridColor = currentGridColor();

      return new Chart(canvas.getContext("2d"), {
        type: "scatter",
        data: { datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          plugins: {
            legend: {
              display: true,
              position: "top",
              labels: { color: textColor }
            },
            tooltip: {
              callbacks: {
                title: (items) => {
                  // Use created_at label stored on the point object
                  const p = items?.[0]?.raw;
                  return p?.created_at_label ? p.created_at_label : "";
                },
                label: (item) => {
                  const y = item?.raw?.y;
                  return Number.isFinite(y) ? `Value: ${y}` : `Value: ${y}`;
                }
              }
            }
          },
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Time (created_at)", color: textColor },
              ticks: { color: textColor, callback: (val) => formatEpochTick(val) },
              grid: { color: gridColor }
            },
            y: {
              title: { display: true, text: yLabel, color: textColor },
              ticks: { color: textColor },
              grid: { color: gridColor }
            }
          },
          elements: {
            line: { tension: 0.15 },
            point: { radius: 2.2, hoverRadius: 5 }
          }
        }
      });
    }

    function makeChartCard(titleText){
      const card = document.createElement("div");
      card.className = "card chartCard";
      const h = document.createElement("h3");
      h.textContent = titleText;
      const canvas = document.createElement("canvas");
      card.appendChild(h);
      card.appendChild(canvas);
      return { card, canvas };
    }

    function destroyAllCharts(){
      for (const c of moistCharts) c?.destroy?.();
      for (const c of tempCharts)  c?.destroy?.();
      moistCharts = new Array(8).fill(null);
      tempCharts  = new Array(8).fill(null);
      moistCards  = new Array(8).fill(null);
      tempCards   = new Array(8).fill(null);
      clearContainers();
    }

    function buildCardsAndChartsOnce(){
      for (let i = 0; i < 8; i++){
        const m = makeChartCard(`Moisture ${depthLabel(i)}`);
        moistCards[i]  = m.card;
        moistCharts[i] = makeDepthChart(m.canvas, "Moisture (units per your sensor)");

        const t = makeChartCard(`Temperature ${depthLabel(i)}`);
        tempCards[i]  = t.card;
        tempCharts[i] = makeDepthChart(t.canvas, "Temperature (°C)");
      }
      placeCardsForViewport();

      window.addEventListener("resize", debounce(() => {
        placeCardsForViewport();
        for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
      }, 150));
    }

    // ---- Data parse / render (NOW uses created_at for x + point labeling) ----
    function buildRowsForSensor(feeds, sensorName){
      const rows = feeds
        .filter(f => (f?.field1 || "").trim() === sensorName)
        .map(f => {
          const createdAt = String(f.created_at || "").trim();
          const ms = parseCreatedAtToMs(createdAt);
          if (!Number.isFinite(ms)) return null;

          const moist = parseFieldSeries(f.field3);
          const temp  = parseFieldSeries(f.field4);
          if (!moist || !temp) return null;

          return {
            ms,
            created_at: createdAt,
            created_at_label: formatCreatedAt(createdAt),
            moist,
            temp
          };
        })
        .filter(Boolean)
        .sort((a,b) => a.ms - b.ms);

      return rows;
    }

    function renderSensor(rows, sensorName){
      for (let i = 0; i < 8; i++){
        const moistData = rows.map(r => ({
          x: r.ms,
          y: r.moist[i],
          created_at_label: r.created_at_label
        }));
        const tempData  = rows.map(r => ({
          x: r.ms,
          y: r.temp[i],
          created_at_label: r.created_at_label
        }));

        moistCharts[i].data.datasets = [{
          label: `Moisture ${DEPTHS_CM[i]} cm`,
          showLine: true,
          data: moistData,
          borderColor: MOIST_COLOR,
          backgroundColor: MOIST_COLOR
        }];

        tempCharts[i].data.datasets = [{
          label: `Temperature ${DEPTHS_CM[i]} cm`,
          showLine: true,
          data: tempData,
          borderColor: TEMP_COLOR,
          backgroundColor: TEMP_COLOR
        }];

        moistCharts[i].update();
        tempCharts[i].update();
      }

      applyChartTheme();

      setStatus((prev => {
        const header = (prev || "").split("\n")[0] || "";
        const headerLine = header.startsWith("Loaded") ? header + "\n" : "";
        const latest = rows.length ? rows[rows.length - 1].created_at_label : "n/a";
        return headerLine + `Showing sensor: ${sensorName}\nUsable rows (parsed): ${rows.length}\nLatest created_at: ${latest}`;
      })(elStatus.textContent));
    }

    async function loadAndRender(){
      elSensorSel.disabled = true;
      elSensorSel.innerHTML = `<option>Loading…</option>`;
      setStatus("Loading ThingSpeak data…");

      const channelId = elChannelId.value.trim();
      const readKey   = elReadKey.value.trim();
      const results   = Number.parseInt(elResults.value.trim(), 10) || 800;
      const url = buildThingSpeakUrl(channelId, readKey, results);

      let json;
      try{
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
        json = await res.json();
      } catch(e){
        setStatus(`Failed to fetch.\nURL: ${url}\nError: ${e?.message || e}`);
        elSensorSel.innerHTML = `<option>Load failed</option>`;
        return;
      }

      const feeds = Array.isArray(json?.feeds) ? json.feeds : [];
      if (feeds.length === 0){
        setStatus(`No feeds returned.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No data</option>`;
        return;
      }

      const sensors = uniqueSensors(feeds);
      if (sensors.length === 0){
        setStatus(`No sensors found in field1.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No sensors found</option>`;
        return;
      }

      if (!moistCharts[0] || !tempCharts[0]){
        destroyAllCharts();
        buildCardsAndChartsOnce();
      } else {
        placeCardsForViewport();
        for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
      }

      elSensorSel.disabled = false;
      elSensorSel.innerHTML = sensors.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");

      const defaultSensor = sensors[0];
      const rows = buildRowsForSensor(feeds, defaultSensor);
      renderSensor(rows, defaultSensor);

      elSensorSel.onchange = () => {
        const sensorName = elSensorSel.value;
        const rows2 = buildRowsForSensor(feeds, sensorName);
        renderSensor(rows2, sensorName);
      };

      const chName = json?.channel?.name ? ` (${json.channel.name})` : "";
      setStatus(
        `Loaded ${feeds.length} rows from channel ${channelId}${chName}.\n` +
        `Discovered ${sensors.length} sensor(s). Showing: ${defaultSensor}\n` +
        `Usable rows (parsed): ${rows.length}`
      );
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    // ---- Init ----
    setTheme(getInitialTheme());
    elThemeBtn.addEventListener("click", toggleTheme);
    elLoadBtn.addEventListener("click", loadAndRender);
    loadAndRender();
  </script>

  <!--
    Run locally:
      1) Save as index.html
      2) python3 -m http.server 8000
      3) Open http://localhost:8000
  -->
</body>
</html>
