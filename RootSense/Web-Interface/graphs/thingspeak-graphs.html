<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ThingSpeak Soil Graphs (Moisture + Temp)</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      padding: 16px;
      max-width: 1100px;
      margin-inline: auto;
    }
    h1 { font-size: 1.2rem; margin: 0 0 12px; }
    .card {
      border: 1px solid color-mix(in srgb, CanvasText 20%, transparent);
      border-radius: 12px;
      padding: 12px;
      margin: 12px 0;
      background: color-mix(in srgb, Canvas 92%, CanvasText 8%);
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 900px) {
      .row { grid-template-columns: 1fr; }
    }
    label { display: block; font-size: 0.9rem; margin-bottom: 6px; }
    input, select, button {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid color-mix(in srgb, CanvasText 20%, transparent);
      background: Canvas;
      color: CanvasText;
      box-sizing: border-box;
    }
    button { cursor: pointer; font-weight: 600; }
    .grid3 {
      display: grid;
      grid-template-columns: 1.2fr 1.2fr 0.6fr;
      gap: 12px;
      align-items: end;
    }
    @media (max-width: 900px) {
      .grid3 { grid-template-columns: 1fr; }
    }
    .status {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      white-space: pre-wrap;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    .charts {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    canvas { width: 100% !important; height: 420px !important; }
    .muted { opacity: 0.8; font-size: 0.95rem; }
  </style>
</head>
<body>
  <h1>ThingSpeak Soil Sensor Visualization</h1>

  <div class="card">
    <div class="grid3">
      <div>
        <label for="channelId">Channel ID</label>
        <input id="channelId" value="3002040" inputmode="numeric" />
      </div>
      <div>
        <label for="readKey">Read API Key (optional for public channels)</label>
        <input id="readKey" placeholder="XXXXXXXXXXXXXXXX" />
      </div>
      <div>
        <label for="results"># Results</label>
        <input id="results" value="800" inputmode="numeric" />
      </div>
    </div>

    <div style="display:grid; grid-template-columns: 1fr 0.35fr; gap: 12px; margin-top: 12px;">
      <div>
        <label for="sensorSelect">Select sensor (field1)</label>
        <select id="sensorSelect" disabled>
          <option>Load data first…</option>
        </select>
        <div class="muted" style="margin-top:6px;">
          Sensors are discovered from <b>field1</b>. Example values: <code>hub</code>, <code>9f48: @w1r</code>, <code>5f90: @w2r</code>.
        </div>
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="loadBtn">Load / Refresh</button>
      </div>
    </div>

    <div class="status" id="status" style="margin-top:12px;"></div>
  </div>

  <div class="charts">
    <div class="card">
      <h2 style="margin:0 0 8px; font-size:1.05rem;">Soil Moisture (8 depths)</h2>
      <canvas id="moistChart"></canvas>
    </div>

    <div class="card">
      <h2 style="margin:0 0 8px; font-size:1.05rem;">Soil Temperature (°C, 8 depths)</h2>
      <canvas id="tempChart"></canvas>
    </div>
  </div>

  <!-- Chart.js (single dependency, easiest way to get scatter + connected lines + legend) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    // ---- Depth labels (8 values) ----
    const DEPTHS_CM = [-10, -20, -30, -40, -50, -60, -70, -80];
    const depthLabel = (i) => `${DEPTHS_CM[i]} cm`;

    // ---- Minimal line colors (stable + distinct) ----
    // (No library needed; just a fixed palette.)
    const PALETTE = [
      "#1f77b4","#ff7f0e","#2ca02c","#d62728",
      "#9467bd","#8c564b","#e377c2","#7f7f7f"
    ];

    // ---- DOM ----
    const elChannelId = document.getElementById("channelId");
    const elReadKey   = document.getElementById("readKey");
    const elResults   = document.getElementById("results");
    const elLoadBtn   = document.getElementById("loadBtn");
    const elSensorSel = document.getElementById("sensorSelect");
    const elStatus    = document.getElementById("status");

    // ---- Charts ----
    let moistChart = null;
    let tempChart  = null;

    function setStatus(msg) {
      elStatus.textContent = msg;
    }

    function buildThingSpeakUrl(channelId, readKey, results) {
      const base = `https://api.thingspeak.com/channels/${encodeURIComponent(channelId)}/feeds.json`;
      const params = new URLSearchParams();
      params.set("results", String(results || 800));
      if (readKey && readKey.trim().length > 0) params.set("api_key", readKey.trim());
      return `${base}?${params.toString()}`;
    }

    function parseSignedFloat(s) {
      // Handles "+002.14", "-001.05", "0.00", etc.
      const v = Number.parseFloat(String(s).trim());
      return Number.isFinite(v) ? v : null;
    }

    function parseFieldSeries(fieldStr, expectedPrefix) {
      // Example:
      // "Moist,+002.14,+003.83,...(8 values)"
      // "Temp,+030.12,+028.46,...(8 values)"
      if (!fieldStr || typeof fieldStr !== "string") return null;

      const parts = fieldStr.split(",").map(x => x.trim()).filter(Boolean);
      if (parts.length < 2) return null;

      const prefix = parts[0];
      if (expectedPrefix && prefix.toLowerCase() !== expectedPrefix.toLowerCase()) {
        // Still try, but keep it permissive
      }

      const nums = parts.slice(1).map(parseSignedFloat);
      if (nums.some(v => v === null)) return null;

      // Expect exactly 8 values; if not, reject to avoid mis-plotting.
      if (nums.length !== 8) return null;

      return nums;
    }

    function uniqueSensors(feeds) {
      const set = new Set();
      for (const f of feeds) {
        if (f && typeof f.field1 === "string" && f.field1.trim().length > 0) {
          set.add(f.field1.trim());
        }
      }
      return Array.from(set).sort((a,b) => a.localeCompare(b));
    }

    function formatEpochTick(value) {
      // value is epoch seconds
      const ms = Number(value) * 1000;
      const d = new Date(ms);
      if (Number.isNaN(d.getTime())) return String(value);
      return d.toLocaleString();
    }

    function destroyCharts() {
      if (moistChart) { moistChart.destroy(); moistChart = null; }
      if (tempChart)  { tempChart.destroy();  tempChart  = null; }
    }

    function makeChart(ctx, title, yLabel) {
      return new Chart(ctx, {
        type: "scatter",
        data: { datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false, // we provide {x,y}
          plugins: {
            legend: { position: "top" },
            tooltip: {
              callbacks: {
                title: (items) => {
                  const x = items?.[0]?.raw?.x;
                  return x != null ? formatEpochTick(x) : "";
                }
              }
            },
            title: { display: false, text: title }
          },
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Time" },
              ticks: {
                callback: (val) => formatEpochTick(val)
              }
            },
            y: {
              title: { display: true, text: yLabel }
            }
          },
          elements: {
            line: { tension: 0.15 },
            point: { radius: 2.2, hoverRadius: 5 }
          }
        }
      });
    }

    function buildDatasetsForSensor(feeds, sensorName) {
      // Filter by sensor and keep only rows that have parseable field2 + field3/field4.
      const rows = feeds
        .filter(f => (f?.field1 || "").trim() === sensorName)
        .map(f => {
          const epoch = Number.parseInt(String(f.field2 || "").trim(), 10);
          if (!Number.isFinite(epoch)) return null;

          const moist = parseFieldSeries(f.field3, "Moist");
          const temp  = parseFieldSeries(f.field4, "Temp");
          if (!moist || !temp) return null;

          return { epoch, moist, temp };
        })
        .filter(Boolean)
        .sort((a,b) => a.epoch - b.epoch);

      // One dataset per depth
      const moistDatasets = [];
      const tempDatasets  = [];

      for (let i = 0; i < 8; i++) {
        moistDatasets.push({
          label: `Moist ${depthLabel(i)}`,
          showLine: true,
          data: rows.map(r => ({ x: r.epoch, y: r.moist[i] })),
          borderColor: PALETTE[i],
          backgroundColor: PALETTE[i]
        });

        tempDatasets.push({
          label: `Temp ${depthLabel(i)}`,
          showLine: true,
          data: rows.map(r => ({ x: r.epoch, y: r.temp[i] })),
          borderColor: PALETTE[i],
          backgroundColor: PALETTE[i]
        });
      }

      return { rowsCount: rows.length, moistDatasets, tempDatasets };
    }

    async function loadAndRender() {
      destroyCharts();
      elSensorSel.disabled = true;
      elSensorSel.innerHTML = `<option>Loading…</option>`;
      setStatus("Loading ThingSpeak data…");

      const channelId = elChannelId.value.trim();
      const readKey   = elReadKey.value.trim();
      const results   = Number.parseInt(elResults.value.trim(), 10) || 800;

      const url = buildThingSpeakUrl(channelId, readKey, results);

      let json;
      try {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
        json = await res.json();
      } catch (e) {
        setStatus(`Failed to fetch.\nURL: ${url}\nError: ${e?.message || e}`);
        elSensorSel.innerHTML = `<option>Load failed</option>`;
        return;
      }

      const feeds = Array.isArray(json?.feeds) ? json.feeds : [];
      if (feeds.length === 0) {
        setStatus(`No feeds returned.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No data</option>`;
        return;
      }

      const sensors = uniqueSensors(feeds);
      if (sensors.length === 0) {
        setStatus(`No sensors found in field1.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No sensors found</option>`;
        return;
      }

      // Fill dropdown
      elSensorSel.disabled = false;
      elSensorSel.innerHTML = sensors.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");

      // Create charts
      moistChart = makeChart(document.getElementById("moistChart"), "Soil Moisture", "Moisture (units per your sensor)");
      tempChart  = makeChart(document.getElementById("tempChart"),  "Soil Temp",     "Temperature (°C)");

      // Render default sensor (first)
      const defaultSensor = sensors[0];
      renderSensor(feeds, defaultSensor);

      // Wire change event
      elSensorSel.onchange = () => renderSensor(feeds, elSensorSel.value);

      const chName = json?.channel?.name ? ` (${json.channel.name})` : "";
      setStatus(
        `Loaded ${feeds.length} rows from channel ${channelId}${chName}.\n` +
        `Discovered ${sensors.length} sensor(s). Showing: ${defaultSensor}`
      );
    }

    function renderSensor(feeds, sensorName) {
      const { rowsCount, moistDatasets, tempDatasets } = buildDatasetsForSensor(feeds, sensorName);

      moistChart.data.datasets = moistDatasets;
      tempChart.data.datasets  = tempDatasets;
      moistChart.update();
      tempChart.update();

      setStatus((prev => {
        // Keep the top line from previous status if it exists
        const header = (prev || "").split("\n")[0] || "";
        const headerLine = header.startsWith("Loaded") ? header + "\n" : "";
        return headerLine + `Showing sensor: ${sensorName}\nUsable rows (parsed): ${rowsCount}`;
      })(elStatus.textContent));
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    // ---- UI ----
    elLoadBtn.addEventListener("click", loadAndRender);

    // Auto-load on open
    loadAndRender();
  </script>

  <!--
    How to run locally:
      1) Save this file as index.html
      2) In the same folder:
           python3 -m http.server 8000
      3) Open:
           http://localhost:8000
  -->
</body>
</html>
