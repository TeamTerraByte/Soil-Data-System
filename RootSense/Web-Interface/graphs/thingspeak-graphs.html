<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ThingSpeak Soil Graphs (Zipper + Theme Toggle + Timestamps)</title>

  <style>
    html[data-theme="dark"] { color-scheme: dark; }
    html[data-theme="light"] { color-scheme: light; }

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin:0;
      padding:16px;
      max-width: 1250px;
      margin-inline:auto;
      background: var(--bg);
      color: var(--fg);
    }

    html[data-theme="light"]{
      --bg:#ffffff; --fg:#111111; --card:#f6f7f9; --border:#c8ccd3;
      --input-bg:#ffffff; --input-fg:#111111; --muted:rgba(0,0,0,0.75);
      --btn-bg:#111111; --btn-fg:#ffffff; --btn-border:#111111;
      --error:#b00020;
    }

    html[data-theme="dark"]{
      --bg:#0b0d10; --fg:#ffffff; --card:#121620; --border:rgba(255,255,255,0.20);
      --input-bg:#0f131b; --input-fg:#ffffff; --muted:rgba(255,255,255,0.80);
      --btn-bg:#ffffff; --btn-fg:#111111; --btn-border:#ffffff;
      --error:#ff6b6b;
    }

    h1{ font-size:1.2rem; margin:0; }
    h2{ font-size:1.05rem; margin:0 0 10px; }
    h3{ font-size:1rem; margin:0 0 8px; }

    .topbar{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap:12px;
      margin-bottom: 12px;
    }
    .themeBtn{
      width:auto;
      padding:10px 12px;
      border-radius: 10px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-fg);
      font-weight: 700;
      cursor: pointer;
      white-space: nowrap;
    }

    .card{
      border:1px solid var(--border);
      border-radius:12px;
      padding:12px;
      margin:12px 0;
      background: var(--card);
    }

    label{ display:block; font-size:.9rem; margin-bottom:6px; color: var(--fg); }
    input, select, button{
      width:100%;
      padding:10px;
      border-radius:10px;
      border:1px solid var(--border);
      background: var(--input-bg);
      color: var(--input-fg);
      box-sizing:border-box;
    }
    button{ cursor:pointer; font-weight:600; }

    .grid3{
      display:grid;
      grid-template-columns: 1.2fr 1.2fr 0.6fr;
      gap:12px;
      align-items:end;
    }

    .row2{
      display:grid;
      grid-template-columns: 1fr 0.35fr;
      gap:12px;
      align-items:end;
      margin-top:12px;
    }

    /* Simplified date UI: text range + multi-day picker */
    .rowDateSimple{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:12px;
      align-items:end;
      margin-top:12px;
    }

    @media (max-width: 900px){
      .grid3{ grid-template-columns:1fr; }
      .row2{ grid-template-columns:1fr; }
      .rowDateSimple{ grid-template-columns:1fr; }
      .topbar{ flex-direction: column; align-items: stretch; }
      .themeBtn{ width: 100%; }
    }

    .muted{ color: var(--muted); font-size:.95rem; margin-top:6px; }
    .status{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      white-space: pre-wrap;
      font-size: .9rem;
      color: var(--muted);
      margin-top: 12px;
    }
    .errorText{
      color: var(--error);
      font-weight: 600;
      margin-top: 8px;
      white-space: pre-wrap;
      font-size: .95rem;
    }

    .pillRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:8px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      background: var(--input-bg);
      color: var(--input-fg);
      font-size: .9rem;
      user-select:none;
    }
    .pill button{
      width:auto;
      padding:0 6px;
      border-radius:999px;
      border:1px solid var(--border);
      background: transparent;
      color: inherit;
      cursor:pointer;
      font-weight:700;
    }

    /* Desktop: two columns (moist left, temp right) */
    .twoCol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      align-items:start;
    }
    .col{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }

    /* Mobile: zipper merge */
    .zipper{
      display:none;
      grid-template-columns: 1fr;
      gap:14px;
    }
    @media (max-width: 900px){
      .twoCol{ display:none; }
      .zipper{ display:grid; }
    }

    .chartCard canvas{ width:100% !important; height:260px !important; }
  </style>
</head>

<body>
  <div class="topbar">
    <h1>ThingSpeak Soil Sensor Visualization</h1>
    <button class="themeBtn" id="themeToggleBtn" type="button">Toggle Dark/Light</button>
  </div>

  <div class="card">
    <div class="grid3">
      <div>
        <label for="channelId">Channel ID</label>
        <input id="channelId" value="3002040" inputmode="numeric" />
      </div>
      <div>
        <label for="readKey">Read API Key (optional for public channels)</label>
        <input id="readKey" placeholder="XXXXXXXXXXXXXXXX" />
      </div>
      <div>
        <label for="results"># Results</label>
        <input id="results" value="200" inputmode="numeric" />
      </div>
    </div>

    <div class="row2">
      <div>
        <label for="sensorSelect">Select sensor (field1)</label>
        <select id="sensorSelect" disabled>
          <option>Load data first…</option>
        </select>
        <div class="muted">Hover a point to see its <b>created_at</b> timestamp.</div>
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="loadBtn" type="button">Load / Refresh</button>
      </div>
    </div>

    <!-- Simplified date interface -->
    <div class="rowDateSimple">
      <div>
        <label for="startText">Start (text)</label>
        <input id="startText" placeholder="YYYY-MM-DD HH:MM[:SS]" />
      </div>
      <div>
        <label for="endText">End (text)</label>
        <input id="endText" placeholder="YYYY-MM-DD HH:MM[:SS]" />
      </div>
      <div>
        <label for="dayPicker">Pick day(s) (GUI)</label>
        <input id="dayPicker" type="date" />
        <div class="muted" id="validRangeText"></div>
      </div>
    </div>

    <div class="pillRow" id="selectedDaysRow" aria-label="Selected days"></div>
    <div class="muted">
      Day selection is <b>OR</b> with the text range:
      if you pick any days, the charts show only data whose <b>created_at</b> date matches those days.
      Clear selected days to use the text range again.
    </div>

    <div class="errorText" id="dateError"></div>
    <div class="status" id="status"></div>
  </div>

  <!-- Desktop / tablet layout -->
  <div class="card twoCol" id="twoColLayout">
    <div class="col">
      <h2>Moisture</h2>
      <div id="moistCol"></div>
    </div>
    <div class="col">
      <h2>Temperature (°C)</h2>
      <div id="tempCol"></div>
    </div>
  </div>

  <!-- Mobile zipper-merged layout -->
  <div class="card zipper" id="zipperLayout">
    <h2>Moisture + Temperature (Zipper)</h2>
    <div id="zipperCol"></div>
  </div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script>
    const DEPTHS_CM = [-10, -20, -30, -40, -50, -60, -70, -80];
    const depthLabel = (i) => `${DEPTHS_CM[i]} cm`;

    const MOIST_COLOR = "#1f77b4";
    const TEMP_COLOR  = "#d62728";

    // DOM
    const elChannelId = document.getElementById("channelId");
    const elReadKey   = document.getElementById("readKey");
    const elResults   = document.getElementById("results");
    const elLoadBtn   = document.getElementById("loadBtn");
    const elSensorSel = document.getElementById("sensorSelect");
    const elStatus    = document.getElementById("status");
    const elThemeBtn  = document.getElementById("themeToggleBtn");

    const elMoistCol  = document.getElementById("moistCol");
    const elTempCol   = document.getElementById("tempCol");
    const elZipperCol = document.getElementById("zipperCol");

    // Date UI (simplified)
    const elStartText = document.getElementById("startText");
    const elEndText   = document.getElementById("endText");
    const elDayPicker = document.getElementById("dayPicker");
    const elSelectedDaysRow = document.getElementById("selectedDaysRow");
    const elValidRangeText = document.getElementById("validRangeText");
    const elDateError = document.getElementById("dateError");

    let moistCharts = new Array(8).fill(null);
    let tempCharts  = new Array(8).fill(null);
    let moistCards  = new Array(8).fill(null);
    let tempCards   = new Array(8).fill(null);

    // Cached fetch
    let lastFeeds = [];
    let currentSensorName = null;

    // Global min/max from fetched data
    let dataMinMs = null;
    let dataMaxMs = null;

    // Active filter state
    let activeStartMs = null;
    let activeEndMs   = null;

    // Multi-day selection: store as YYYY-MM-DD strings (local date)
    const selectedDays = new Set();

    function setStatus(msg){ elStatus.textContent = msg; }
    function setDateError(msg){ elDateError.textContent = msg || ""; }

    // ---- Theme ----
    function getInitialTheme(){
      const saved = localStorage.getItem("rs_theme");
      if (saved === "dark" || saved === "light") return saved;
      const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
      return prefersDark ? "dark" : "light";
    }
    function currentGraphTextColor(){
      const theme = document.documentElement.getAttribute("data-theme") || "dark";
      return theme === "light" ? "#000000" : "#ffffff";
    }
    function currentGridColor(){
      const theme = document.documentElement.getAttribute("data-theme") || "dark";
      return theme === "light" ? "rgba(0,0,0,0.12)" : "rgba(255,255,255,0.15)";
    }
    function applyChartTheme(){
      const textColor = currentGraphTextColor();
      const gridColor = currentGridColor();
      for (const chart of [...moistCharts, ...tempCharts]){
        if (!chart) continue;
        chart.options.plugins.legend.labels.color = textColor;

        chart.options.scales.x.title.color = textColor;
        chart.options.scales.x.ticks.color = textColor;
        chart.options.scales.x.grid.color  = gridColor;

        chart.options.scales.y.title.color = textColor;
        chart.options.scales.y.ticks.color = textColor;
        chart.options.scales.y.grid.color  = gridColor;

        chart.update();
      }
    }
    function setTheme(theme){
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem("rs_theme", theme);
      applyChartTheme();
      for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
    }
    function toggleTheme(){
      const cur = document.documentElement.getAttribute("data-theme") || "dark";
      setTheme(cur === "dark" ? "light" : "dark");
    }

    // ---- ThingSpeak helpers ----
    function buildThingSpeakUrl(channelId, readKey, results){
      const base = `https://api.thingspeak.com/channels/${encodeURIComponent(channelId)}/feeds.json`;
      const params = new URLSearchParams();
      params.set("results", String(results || 200));
      if (readKey && readKey.trim().length > 0) params.set("api_key", readKey.trim());
      return `${base}?${params.toString()}`;
    }
    function parseSignedFloat(s){
      const v = Number.parseFloat(String(s).trim());
      return Number.isFinite(v) ? v : null;
    }
    function parseFieldSeries(fieldStr){
      if (!fieldStr || typeof fieldStr !== "string") return null;
      const parts = fieldStr.split(",").map(x => x.trim()).filter(Boolean);
      if (parts.length < 2) return null;
      const nums = parts.slice(1).map(parseSignedFloat);
      if (nums.some(v => v === null)) return null;
      if (nums.length !== 8) return null;
      return nums;
    }
    function uniqueSensors(feeds){
      const set = new Set();
      for (const f of feeds){
        const s = (f?.field1 || "").trim();
        if (s) set.add(s);
      }
      return Array.from(set).sort((a,b) => a.localeCompare(b));
    }

    function parseCreatedAtToMs(createdAt){
      const ms = new Date(createdAt).getTime();
      return Number.isFinite(ms) ? ms : null;
    }
    function formatCreatedAt(createdAt){
      const d = new Date(createdAt);
      if (Number.isNaN(d.getTime())) return String(createdAt);
      return d.toLocaleString();
    }
    function formatEpochTick(value){
      const d = new Date(Number(value));
      if (Number.isNaN(d.getTime())) return String(value);
      return d.toLocaleString();
    }

    // Convert ms to local YYYY-MM-DD
    function msToLocalDay(ms){
      const d = new Date(ms);
      const pad = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
    }

    // ---- Text range parsing/validation ----
    // Accepts "YYYY-MM-DD HH:MM[:SS]" or "YYYY-MM-DDTHH:MM[:SS]"
    function parseTypedDateToMs(s){
      if (!s || typeof s !== "string") return null;
      const t = s.trim();
      if (!t) return null;
      const normalized = t.includes("T") ? t : t.replace(" ", "T");
      const ms = new Date(normalized).getTime();
      return Number.isFinite(ms) ? ms : null;
    }

    function computeGlobalMinMaxMs(feeds){
      let min = Infinity;
      let max = -Infinity;
      for (const f of feeds){
        const ms = parseCreatedAtToMs(f?.created_at);
        if (!Number.isFinite(ms)) continue;
        if (ms < min) min = ms;
        if (ms > max) max = ms;
      }
      if (!Number.isFinite(min) || !Number.isFinite(max) || min === Infinity || max === -Infinity) {
        return { minMs: null, maxMs: null };
      }
      return { minMs: min, maxMs: max };
    }

    function updateValidRangeUI(){
      if (!Number.isFinite(dataMinMs) || !Number.isFinite(dataMaxMs)) {
        elValidRangeText.textContent = "";
        elDayPicker.min = "";
        elDayPicker.max = "";
        return;
      }
      const minStr = new Date(dataMinMs).toLocaleString();
      const maxStr = new Date(dataMaxMs).toLocaleString();
      elValidRangeText.textContent = `Valid: ${minStr} → ${maxStr}`;

      // dayPicker limits (YYYY-MM-DD)
      elDayPicker.min = msToLocalDay(dataMinMs);
      elDayPicker.max = msToLocalDay(dataMaxMs);
    }

    function setDefaultTextRangeFromData(){
      if (!Number.isFinite(dataMinMs) || !Number.isFinite(dataMaxMs)) return;
      activeStartMs = dataMinMs;
      activeEndMs   = dataMaxMs;
      elStartText.value = new Date(activeStartMs).toLocaleString();
      elEndText.value   = new Date(activeEndMs).toLocaleString();
    }

    function validateAndApplyTextRange(){
      setDateError("");

      if (!Number.isFinite(dataMinMs) || !Number.isFinite(dataMaxMs)) {
        setDateError("Load data first so the valid date range can be determined.");
        return false;
      }

      const startMs = parseTypedDateToMs(elStartText.value);
      const endMs   = parseTypedDateToMs(elEndText.value);

      if (!Number.isFinite(startMs) || !Number.isFinite(endMs)) {
        setDateError("Invalid start/end. Use: 2026-01-07 10:43:12 (or 2026-01-07T10:43:12)");
        return false;
      }
      if (startMs > endMs) {
        setDateError("Start must be earlier than (or equal to) End.");
        return false;
      }
      if (startMs < dataMinMs || endMs > dataMaxMs) {
        setDateError(
          `Out of range. Choose between:\n${new Date(dataMinMs).toLocaleString()}\n${new Date(dataMaxMs).toLocaleString()}`
        );
        return false;
      }

      activeStartMs = startMs;
      activeEndMs   = endMs;

      // When text range is applied, clear selected days (so it's unambiguous)
      selectedDays.clear();
      renderSelectedDays();

      rerenderAll();
      return true;
    }

    // ---- Multi-day GUI selection ----
    function renderSelectedDays(){
      elSelectedDaysRow.innerHTML = "";
      const days = Array.from(selectedDays).sort();

      if (days.length === 0) return;

      for (const day of days){
        const pill = document.createElement("div");
        pill.className = "pill";
        const span = document.createElement("span");
        span.textContent = day;
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = "×";
        btn.title = "Remove day";
        btn.addEventListener("click", () => {
          selectedDays.delete(day);
          renderSelectedDays();
          rerenderAll();
        });
        pill.appendChild(span);
        pill.appendChild(btn);
        elSelectedDaysRow.appendChild(pill);
      }
    }

    function validateDayWithinRange(dayStr){
      if (!Number.isFinite(dataMinMs) || !Number.isFinite(dataMaxMs)) return false;
      if (!/^\d{4}-\d{2}-\d{2}$/.test(dayStr)) return false;
      const minDay = msToLocalDay(dataMinMs);
      const maxDay = msToLocalDay(dataMaxMs);
      return (dayStr >= minDay && dayStr <= maxDay);
    }

    function addSelectedDay(dayStr){
      setDateError("");

      if (!validateDayWithinRange(dayStr)) {
        setDateError(`Day is out of range. Choose between ${msToLocalDay(dataMinMs)} and ${msToLocalDay(dataMaxMs)}.`);
        return false;
      }

      // If user is using days, we ignore text range.
      // Clear text range state but keep values in boxes (so user can return to it).
      selectedDays.add(dayStr);
      renderSelectedDays();
      rerenderAll();
      return true;
    }

    // ---- Layout ----
    function isMobile(){ return window.matchMedia("(max-width: 900px)").matches; }
    function clearContainers(){
      elMoistCol.innerHTML  = "";
      elTempCol.innerHTML   = "";
      elZipperCol.innerHTML = "";
    }
    function placeCardsForViewport(){
      clearContainers();
      if (isMobile()){
        for (let i = 0; i < 8; i++){
          elZipperCol.appendChild(moistCards[i]);
          elZipperCol.appendChild(tempCards[i]);
        }
      } else {
        for (let i = 0; i < 8; i++){
          elMoistCol.appendChild(moistCards[i]);
          elTempCol.appendChild(tempCards[i]);
        }
      }
    }
    function debounce(fn, wait){
      let t = null;
      return (...args) => {
        if (t) clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    // ---- Charts ----
    function makeDepthChart(canvas, yLabel){
      const textColor = currentGraphTextColor();
      const gridColor = currentGridColor();

      return new Chart(canvas.getContext("2d"), {
        type: "scatter",
        data: { datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          plugins: {
            legend: {
              display: true,
              position: "top",
              labels: { color: textColor }
            },
            tooltip: {
              enabled: true,
              mode: "nearest",
              intersect: true,
              callbacks: {
                title: (items) => {
                  const p = items?.[0]?.raw;
                  return p?.created_at_label ? p.created_at_label : "";
                },
                label: (item) => {
                  const y = item?.raw?.y;
                  return Number.isFinite(y) ? `Value: ${y}` : `Value: ${y}`;
                }
              }
            }
          },
          interaction: {
            mode: "nearest",
            intersect: true,
            axis: "xy"
          },
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Time (created_at)", color: textColor },
              ticks: { color: textColor, callback: (val) => formatEpochTick(val) },
              grid: { color: gridColor }
            },
            y: {
              title: { display: true, text: yLabel, color: textColor },
              ticks: { color: textColor },
              grid: { color: gridColor }
            }
          },
          elements: {
            line: { tension: 0.15 },
            point: {
              radius: 2.2,
              hoverRadius: 5,
              hitRadius: 10
            }
          }
        }
      });
    }

    function makeChartCard(titleText){
      const card = document.createElement("div");
      card.className = "card chartCard";
      const h = document.createElement("h3");
      h.textContent = titleText;
      const canvas = document.createElement("canvas");
      card.appendChild(h);
      card.appendChild(canvas);
      return { card, canvas };
    }

    function destroyAllCharts(){
      for (const c of moistCharts) c?.destroy?.();
      for (const c of tempCharts)  c?.destroy?.();
      moistCharts = new Array(8).fill(null);
      tempCharts  = new Array(8).fill(null);
      moistCards  = new Array(8).fill(null);
      tempCards   = new Array(8).fill(null);
      clearContainers();
    }

    function buildCardsAndChartsOnce(){
      for (let i = 0; i < 8; i++){
        const m = makeChartCard(`Moisture ${depthLabel(i)}`);
        moistCards[i]  = m.card;
        moistCharts[i] = makeDepthChart(m.canvas, "Moisture (units per your sensor)");

        const t = makeChartCard(`Temperature ${depthLabel(i)}`);
        tempCards[i]  = t.card;
        tempCharts[i] = makeDepthChart(t.canvas, "Temperature (°C)");
      }
      placeCardsForViewport();

      window.addEventListener("resize", debounce(() => {
        placeCardsForViewport();
        for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
      }, 150));
    }

    // ---- Filtering logic ----
    function passesFilter(ms){
      // If any days selected, filter by day-of-created_at (local)
      if (selectedDays.size > 0) {
        const day = msToLocalDay(ms);
        return selectedDays.has(day);
      }

      // Otherwise, use the text range
      if (Number.isFinite(activeStartMs) && ms < activeStartMs) return false;
      if (Number.isFinite(activeEndMs) && ms > activeEndMs) return false;
      return true;
    }

    // ---- Data parse / render ----
    function buildRowsForSensor(feeds, sensorName){
      const rows = feeds
        .filter(f => (f?.field1 || "").trim() === sensorName)
        .map(f => {
          const createdAt = String(f.created_at || "").trim();
          const ms = parseCreatedAtToMs(createdAt);
          if (!Number.isFinite(ms)) return null;

          if (!passesFilter(ms)) return null;

          const moist = parseFieldSeries(f.field3);
          const temp  = parseFieldSeries(f.field4);
          if (!moist || !temp) return null;

          return {
            ms,
            created_at: createdAt,
            created_at_label: formatCreatedAt(createdAt),
            moist,
            temp
          };
        })
        .filter(Boolean)
        .sort((a,b) => a.ms - b.ms);

      return rows;
    }

    function renderSensor(rows, sensorName){
      currentSensorName = sensorName;

      for (let i = 0; i < 8; i++){
        const moistData = rows.map(r => ({
          x: r.ms,
          y: r.moist[i],
          created_at_label: r.created_at_label
        }));
        const tempData  = rows.map(r => ({
          x: r.ms,
          y: r.temp[i],
          created_at_label: r.created_at_label
        }));

        moistCharts[i].data.datasets = [{
          label: `Moisture ${DEPTHS_CM[i]} cm`,
          showLine: true,
          data: moistData,
          borderColor: MOIST_COLOR,
          backgroundColor: MOIST_COLOR
        }];

        tempCharts[i].data.datasets = [{
          label: `Temperature ${DEPTHS_CM[i]} cm`,
          showLine: true,
          data: tempData,
          borderColor: TEMP_COLOR,
          backgroundColor: TEMP_COLOR
        }];

        moistCharts[i].update();
        tempCharts[i].update();
      }

      applyChartTheme();

      const earliest = rows.length ? rows[0].created_at_label : "n/a";
      const latest = rows.length ? rows[rows.length - 1].created_at_label : "n/a";

      const filterInfo = (selectedDays.size > 0)
        ? `Days: ${Array.from(selectedDays).sort().join(", ")}`
        : `Range: ${new Date(activeStartMs).toLocaleString()} → ${new Date(activeEndMs).toLocaleString()}`;

      setStatus((prev => {
        const header = (prev || "").split("\n")[0] || "";
        const headerLine = header.startsWith("Loaded") ? header + "\n" : "";
        return headerLine +
          `Showing sensor: ${sensorName}\n` +
          `Usable rows (in view): ${rows.length}\n` +
          `Earliest in view: ${earliest}\n` +
          `Latest in view: ${latest}\n` +
          `Filter: ${filterInfo}`;
      })(elStatus.textContent));
    }

    function rerenderAll(){
      if (!currentSensorName || !Array.isArray(lastFeeds) || lastFeeds.length === 0) return;
      const rows = buildRowsForSensor(lastFeeds, currentSensorName);
      renderSensor(rows, currentSensorName);
    }

    async function loadAndRender(){
      saveReadKey(elReadKey.value);
      setDateError("");

      elSensorSel.disabled = true;
      elSensorSel.innerHTML = `<option>Loading…</option>`;
      setStatus("Loading ThingSpeak data…");

      const channelId = elChannelId.value.trim();
      const readKey   = elReadKey.value.trim();
      const results   = Number.parseInt(elResults.value.trim(), 10) || 200;
      const url = buildThingSpeakUrl(channelId, readKey, results);

      let json;
      try{
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
        json = await res.json();
      } catch(e){
        setStatus(`Failed to fetch.\nURL: ${url}\nError: ${e?.message || e}`);
        elSensorSel.innerHTML = `<option>Load failed</option>`;
        return;
      }

      const feeds = Array.isArray(json?.feeds) ? json.feeds : [];
      if (feeds.length === 0){
        setStatus(`No feeds returned.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No data</option>`;
        return;
      }

      lastFeeds = feeds;

      const mm = computeGlobalMinMaxMs(feeds);
      dataMinMs = mm.minMs;
      dataMaxMs = mm.maxMs;
      updateValidRangeUI();

      // If first load, default the range to full (and no days selected)
      if (!Number.isFinite(activeStartMs) || !Number.isFinite(activeEndMs) ||
          activeStartMs < dataMinMs || activeEndMs > dataMaxMs) {
        selectedDays.clear();
        renderSelectedDays();
        setDefaultTextRangeFromData();
      }

      const sensors = uniqueSensors(feeds);
      if (sensors.length === 0){
        setStatus(`No sensors found in field1.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No sensors found</option>`;
        return;
      }

      if (!moistCharts[0] || !tempCharts[0]){
        destroyAllCharts();
        buildCardsAndChartsOnce();
      } else {
        placeCardsForViewport();
        for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
      }

      elSensorSel.disabled = false;
      elSensorSel.innerHTML = sensors.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");

      const defaultSensor = sensors[0];
      const rows = buildRowsForSensor(feeds, defaultSensor);
      renderSensor(rows, defaultSensor);

      elSensorSel.onchange = () => {
        const sensorName = elSensorSel.value;
        const rows2 = buildRowsForSensor(lastFeeds, sensorName);
        renderSensor(rows2, sensorName);
      };

      const chName = json?.channel?.name ? ` (${json.channel.name})` : "";
      setStatus(
        `Loaded ${feeds.length} rows from channel ${channelId}${chName}.\n` +
        `Discovered ${sensors.length} sensor(s). Showing: ${defaultSensor}\n` +
        `Usable rows (in view): ${rows.length}`
      );
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    // ---- Persist Read API Key (localStorage) ----
    const READKEY_STORAGE_KEY = "rs_thingspeak_read_api_key_v1";

    function loadSavedReadKey() {
      const saved = localStorage.getItem(READKEY_STORAGE_KEY);
      if (saved && typeof saved === "string") {
        elReadKey.value = saved;
      }
    }

    function saveReadKey(value) {
      const v = String(value || "").trim();
      if (v.length === 0) {
        localStorage.removeItem(READKEY_STORAGE_KEY);
      } else {
        localStorage.setItem(READKEY_STORAGE_KEY, v);
      }
    }

    elReadKey.addEventListener("input", () => saveReadKey(elReadKey.value));
    elReadKey.addEventListener("change", () => saveReadKey(elReadKey.value));
    elReadKey.addEventListener("blur", () => saveReadKey(elReadKey.value));

    // ---- Date UI events ----
    // Text range: apply on Enter or when leaving field
    elStartText.addEventListener("keydown", (e) => { if (e.key === "Enter") validateAndApplyTextRange(); });
    elEndText.addEventListener("keydown", (e) => { if (e.key === "Enter") validateAndApplyTextRange(); });
    elStartText.addEventListener("blur", () => { if (elStartText.value.trim() || elEndText.value.trim()) validateAndApplyTextRange(); });
    elEndText.addEventListener("blur", () => { if (elStartText.value.trim() || elEndText.value.trim()) validateAndApplyTextRange(); });

    // Day picker: each selection adds a day to the set (multi-select behavior)
    elDayPicker.addEventListener("change", () => {
      const day = elDayPicker.value; // YYYY-MM-DD
      if (!day) return;
      addSelectedDay(day);
      elDayPicker.value = ""; // allow re-selecting quickly
    });

    // ---- Layout ----
    function isMobile(){ return window.matchMedia("(max-width: 900px)").matches; }
    function clearContainers(){
      elMoistCol.innerHTML  = "";
      elTempCol.innerHTML   = "";
      elZipperCol.innerHTML = "";
    }
    function placeCardsForViewport(){
      clearContainers();
      if (isMobile()){
        for (let i = 0; i < 8; i++){
          elZipperCol.appendChild(moistCards[i]);
          elZipperCol.appendChild(tempCards[i]);
        }
      } else {
        for (let i = 0; i < 8; i++){
          elMoistCol.appendChild(moistCards[i]);
          elTempCol.appendChild(tempCards[i]);
        }
      }
    }
    function debounce(fn, wait){
      let t = null;
      return (...args) => {
        if (t) clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    // ---- Chart cards ----
    function makeChartCard(titleText){
      const card = document.createElement("div");
      card.className = "card chartCard";
      const h = document.createElement("h3");
      h.textContent = titleText;
      const canvas = document.createElement("canvas");
      card.appendChild(h);
      card.appendChild(canvas);
      return { card, canvas };
    }

    // ---- Build cards & charts ----
    function destroyAllCharts(){
      for (const c of moistCharts) c?.destroy?.();
      for (const c of tempCharts)  c?.destroy?.();
      moistCharts = new Array(8).fill(null);
      tempCharts  = new Array(8).fill(null);
      moistCards  = new Array(8).fill(null);
      tempCards   = new Array(8).fill(null);
      clearContainers();
    }

    function buildCardsAndChartsOnce(){
      for (let i = 0; i < 8; i++){
        const m = makeChartCard(`Moisture ${depthLabel(i)}`);
        moistCards[i]  = m.card;
        moistCharts[i] = makeDepthChart(m.canvas, "Moisture (units per your sensor)");

        const t = makeChartCard(`Temperature ${depthLabel(i)}`);
        tempCards[i]  = t.card;
        tempCharts[i] = makeDepthChart(t.canvas, "Temperature (°C)");
      }
      placeCardsForViewport();

      window.addEventListener("resize", debounce(() => {
        placeCardsForViewport();
        for (const c of [...moistCharts, ...tempCharts]) c?.resize?.();
      }, 150));
    }

    // ---- Init ----
    setTheme(getInitialTheme());
    loadSavedReadKey();
    elThemeBtn.addEventListener("click", toggleTheme);
    elLoadBtn.addEventListener("click", loadAndRender);

    // Initial load
    loadAndRender();
  </script>
</body>
</html>
