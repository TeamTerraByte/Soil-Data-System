<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ThingSpeak Soil Graphs (Per-Depth)</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      padding: 16px;
      max-width: 1200px;
      margin-inline: auto;
    }
    h1 { font-size: 1.2rem; margin: 0 0 12px; }
    h2 { font-size: 1.05rem; margin: 0 0 10px; }
    h3 { font-size: 1rem; margin: 0 0 8px; }
    .card {
      border: 1px solid color-mix(in srgb, CanvasText 20%, transparent);
      border-radius: 12px;
      padding: 12px;
      margin: 12px 0;
      background: color-mix(in srgb, Canvas 92%, CanvasText 8%);
    }
    label { display: block; font-size: 0.9rem; margin-bottom: 6px; }
    input, select, button {
      width: 100%;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid color-mix(in srgb, CanvasText 20%, transparent);
      background: Canvas;
      color: CanvasText;
      box-sizing: border-box;
    }
    button { cursor: pointer; font-weight: 600; }
    .grid3 {
      display: grid;
      grid-template-columns: 1.2fr 1.2fr 0.6fr;
      gap: 12px;
      align-items: end;
    }
    @media (max-width: 900px) {
      .grid3 { grid-template-columns: 1fr; }
    }
    .row2 {
      display: grid;
      grid-template-columns: 1fr 0.35fr;
      gap: 12px;
      align-items: end;
      margin-top: 12px;
    }
    @media (max-width: 900px) {
      .row2 { grid-template-columns: 1fr; }
    }
    .status {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      white-space: pre-wrap;
      font-size: 0.9rem;
      opacity: 0.9;
      margin-top: 12px;
    }
    .muted { opacity: 0.8; font-size: 0.95rem; margin-top: 6px; }

    .section {
      margin-top: 14px;
    }

    /* 8 charts laid out in a responsive grid */
    .chartsGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 900px) {
      .chartsGrid { grid-template-columns: 1fr; }
    }
    .chartCard canvas { width: 100% !important; height: 260px !important; }
  </style>
</head>
<body>
  <h1>ThingSpeak Soil Sensor Visualization (Per Depth)</h1>

  <div class="card">
    <div class="grid3">
      <div>
        <label for="channelId">Channel ID</label>
        <input id="channelId" value="3002040" inputmode="numeric" />
      </div>
      <div>
        <label for="readKey">Read API Key (optional for public channels)</label>
        <input id="readKey" placeholder="XXXXXXXXXXXXXXXX" />
      </div>
      <div>
        <label for="results"># Results</label>
        <input id="results" value="800" inputmode="numeric" />
      </div>
    </div>

    <div class="row2">
      <div>
        <label for="sensorSelect">Select sensor (field1)</label>
        <select id="sensorSelect" disabled>
          <option>Load data first…</option>
        </select>
        <div class="muted">
          Sensors are discovered from <b>field1</b> exactly.
        </div>
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="loadBtn">Load / Refresh</button>
      </div>
    </div>

    <div class="status" id="status"></div>
  </div>

  <div class="section card">
    <h2>Soil Moisture (8 separate graphs)</h2>
    <div class="chartsGrid" id="moistGrid"></div>
  </div>

  <div class="section card">
    <h2>Soil Temperature (°C, 8 separate graphs)</h2>
    <div class="chartsGrid" id="tempGrid"></div>
  </div>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    // Depth order required: -10, -20, -30, ...
    const DEPTHS_CM = [-10, -20, -30, -40, -50, -60, -70, -80];
    const depthLabel = (i) => `${DEPTHS_CM[i]} cm`;

    // Stable palette; reused per chart (single line per chart)
    const LINE_COLOR = "#1f77b4";

    // DOM
    const elChannelId = document.getElementById("channelId");
    const elReadKey   = document.getElementById("readKey");
    const elResults   = document.getElementById("results");
    const elLoadBtn   = document.getElementById("loadBtn");
    const elSensorSel = document.getElementById("sensorSelect");
    const elStatus    = document.getElementById("status");

    const elMoistGrid = document.getElementById("moistGrid");
    const elTempGrid  = document.getElementById("tempGrid");

    // One chart per depth, per type
    let moistCharts = []; // length 8
    let tempCharts  = []; // length 8

    function setStatus(msg) { elStatus.textContent = msg; }

    function buildThingSpeakUrl(channelId, readKey, results) {
      const base = `https://api.thingspeak.com/channels/${encodeURIComponent(channelId)}/feeds.json`;
      const params = new URLSearchParams();
      params.set("results", String(results || 800));
      if (readKey && readKey.trim().length > 0) params.set("api_key", readKey.trim());
      return `${base}?${params.toString()}`;
    }

    function parseSignedFloat(s) {
      const v = Number.parseFloat(String(s).trim());
      return Number.isFinite(v) ? v : null;
    }

    function parseFieldSeries(fieldStr, expectedPrefix) {
      if (!fieldStr || typeof fieldStr !== "string") return null;

      const parts = fieldStr.split(",").map(x => x.trim()).filter(Boolean);
      if (parts.length < 2) return null;

      // Be permissive about prefix, but keep the intent
      // const prefix = parts[0];

      const nums = parts.slice(1).map(parseSignedFloat);
      if (nums.some(v => v === null)) return null;
      if (nums.length !== 8) return null;

      return nums;
    }

    function uniqueSensors(feeds) {
      const set = new Set();
      for (const f of feeds) {
        if (f && typeof f.field1 === "string" && f.field1.trim().length > 0) {
          set.add(f.field1.trim());
        }
      }
      return Array.from(set).sort((a,b) => a.localeCompare(b));
    }

    function formatEpochTick(value) {
      const ms = Number(value) * 1000;
      const d = new Date(ms);
      if (Number.isNaN(d.getTime())) return String(value);
      return d.toLocaleString();
    }

    function destroyAllCharts() {
      for (const c of moistCharts) c?.destroy?.();
      for (const c of tempCharts)  c?.destroy?.();
      moistCharts = [];
      tempCharts  = [];
      elMoistGrid.innerHTML = "";
      elTempGrid.innerHTML  = "";
    }

    function makeDepthChart(canvas, title, yLabel) {
      return new Chart(canvas.getContext("2d"), {
        type: "scatter",
        data: { datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          plugins: {
            legend: { display: true, position: "top" },
            tooltip: {
              callbacks: {
                title: (items) => {
                  const x = items?.[0]?.raw?.x;
                  return x != null ? formatEpochTick(x) : "";
                }
              }
            },
            title: { display: false, text: title }
          },
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Time" },
              ticks: { callback: (val) => formatEpochTick(val) }
            },
            y: { title: { display: true, text: yLabel } }
          },
          elements: {
            line: { tension: 0.15 },
            point: { radius: 2.2, hoverRadius: 5 }
          }
        }
      });
    }

    function createChartCards(containerEl, kindLabel, yLabel) {
      // creates 8 canvases in correct depth order
      const charts = [];
      for (let i = 0; i < 8; i++) {
        const card = document.createElement("div");
        card.className = "card chartCard";

        const h = document.createElement("h3");
        h.textContent = `${kindLabel} ${depthLabel(i)}`;
        card.appendChild(h);

        const canvas = document.createElement("canvas");
        canvas.id = `${kindLabel.toLowerCase()}_${i}`;
        card.appendChild(canvas);

        containerEl.appendChild(card);

        charts.push(makeDepthChart(canvas, `${kindLabel} ${depthLabel(i)}`, yLabel));
      }
      return charts;
    }

    function buildRowsForSensor(feeds, sensorName) {
      // Filter + parse
      const rows = feeds
        .filter(f => (f?.field1 || "").trim() === sensorName)
        .map(f => {
          const epoch = Number.parseInt(String(f.field2 || "").trim(), 10);
          if (!Number.isFinite(epoch)) return null;

          const moist = parseFieldSeries(f.field3, "Moist");
          const temp  = parseFieldSeries(f.field4, "Temp");
          if (!moist || !temp) return null;

          return { epoch, moist, temp };
        })
        .filter(Boolean)
        .sort((a,b) => a.epoch - b.epoch);

      return rows;
    }

    function renderSensor(rows, sensorName) {
      // For each depth, set a single dataset in that depth chart.
      for (let i = 0; i < 8; i++) {
        const moistData = rows.map(r => ({ x: r.epoch, y: r.moist[i] }));
        const tempData  = rows.map(r => ({ x: r.epoch, y: r.temp[i] }));

        moistCharts[i].data.datasets = [{
          label: `Moisture ${depthLabel(i)}`,
          showLine: true,
          data: moistData,
          borderColor: LINE_COLOR,
          backgroundColor: LINE_COLOR
        }];

        tempCharts[i].data.datasets = [{
          label: `Temperature ${depthLabel(i)}`,
          showLine: true,
          data: tempData,
          borderColor: LINE_COLOR,
          backgroundColor: LINE_COLOR
        }];

        moistCharts[i].update();
        tempCharts[i].update();
      }

      setStatus((prev => {
        const header = (prev || "").split("\n")[0] || "";
        const headerLine = header.startsWith("Loaded") ? header + "\n" : "";
        return headerLine + `Showing sensor: ${sensorName}\nUsable rows (parsed): ${rows.length}`;
      })(elStatus.textContent));
    }

    async function loadAndRender() {
      destroyAllCharts();
      elSensorSel.disabled = true;
      elSensorSel.innerHTML = `<option>Loading…</option>`;
      setStatus("Loading ThingSpeak data…");

      const channelId = elChannelId.value.trim();
      const readKey   = elReadKey.value.trim();
      const results   = Number.parseInt(elResults.value.trim(), 10) || 800;

      const url = buildThingSpeakUrl(channelId, readKey, results);

      let json;
      try {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
        json = await res.json();
      } catch (e) {
        setStatus(`Failed to fetch.\nURL: ${url}\nError: ${e?.message || e}`);
        elSensorSel.innerHTML = `<option>Load failed</option>`;
        return;
      }

      const feeds = Array.isArray(json?.feeds) ? json.feeds : [];
      if (feeds.length === 0) {
        setStatus(`No feeds returned.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No data</option>`;
        return;
      }

      const sensors = uniqueSensors(feeds);
      if (sensors.length === 0) {
        setStatus(`No sensors found in field1.\nURL: ${url}`);
        elSensorSel.innerHTML = `<option>No sensors found</option>`;
        return;
      }

      // Build the 8+8 chart grid (in the correct depth order)
      moistCharts = createChartCards(elMoistGrid, "Moisture", "Moisture (units per your sensor)");
      tempCharts  = createChartCards(elTempGrid,  "Temperature", "Temperature (°C)");

      // Fill dropdown
      elSensorSel.disabled = false;
      elSensorSel.innerHTML = sensors.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("");

      // Render default sensor
      const defaultSensor = sensors[0];
      const rows = buildRowsForSensor(feeds, defaultSensor);
      renderSensor(rows, defaultSensor);

      // Wire dropdown
      elSensorSel.onchange = () => {
        const sensorName = elSensorSel.value;
        const rows2 = buildRowsForSensor(feeds, sensorName);
        renderSensor(rows2, sensorName);
      };

      const chName = json?.channel?.name ? ` (${json.channel.name})` : "";
      setStatus(
        `Loaded ${feeds.length} rows from channel ${channelId}${chName}.\n` +
        `Discovered ${sensors.length} sensor(s). Showing: ${defaultSensor}\n` +
        `Usable rows (parsed): ${rows.length}`
      );
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    // UI
    elLoadBtn.addEventListener("click", loadAndRender);
    loadAndRender();

  </script>

  <!--
    Run locally:
      1) Save as index.html
      2) python3 -m http.server 8000
      3) Open http://localhost:8000
  -->
</body>
</html>
